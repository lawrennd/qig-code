---
author: "Neil D. Lawrence"
created: "2025-12-01"
id: "0006"
last_updated: "2025-12-01"
status: proposed
tags:
- cip
- generic
- lie-algebra
- handle-turning
- quantum-dynamics
title: "Implement GENERIC Decomposition for Lie-Algebraic Bases"
---

# CIP-0006: Implement GENERIC Decomposition for Lie-Algebraic Bases

## Summary

Implement a comprehensive computational framework for extracting GENERIC dynamics (effective Hamiltonian and diffusion operator) from the quantum inaccessible game using a Lie-algebraic operator basis. This provides a systematic procedure that decomposes the constrained information-geometric flow into reversible (Hamiltonian) and irreversible (dissipative) components.

## Motivation

The quantum inaccessible game paper establishes that the constrained dynamics on the marginal-entropy manifold can be decomposed into:

1. **Reversible part**: Hamiltonian evolution -i[H_eff, ρ]
2. **Irreversible part**: Dissipative evolution D[ρ]

This GENERIC-like decomposition emerges from the flow Jacobian M = A + S:
- **Antisymmetric part A**: Generates unitary evolution via H_eff
- **Symmetric part S**: Generates dissipative evolution via diffusion operator

The LaTeX document `handle-turning-example.tex` provides an explicit 12-step computational procedure for qutrits, but this is not yet implemented in the `qig` codebase. Having working code that:

1. Takes a state on the constraint manifold
2. Computes the full flow Jacobian M (already implemented in `QuantumExponentialFamily.jacobian()`)
3. Decomposes M = A + S
4. Extracts H_eff from A using Lie algebra structure constants
5. Constructs D[ρ] from S using Kubo-Mori derivatives
6. Integrates the full dynamics

will provide:
- **Validation** of the theoretical framework
- **Numerical verification** of GENERIC structure
- **Concrete examples** for the paper
- **Tool for exploration** of different parameter regimes
- **Reference implementation** for GENERIC decomposition methodology

## Detailed Description

### What Already Exists

The `qig` package already implements most of the computational machinery:

**In `qig.exponential_family.QuantumExponentialFamily`:**
- ✅ `psi(theta)`: Cumulant generating function ψ(θ)
- ✅ `rho_from_theta(theta)`: Density matrix ρ(θ)
- ✅ `_grad_psi(theta)`: Expectation parameters μ = ∇ψ
- ✅ `fisher_information(theta)`: BKM metric G
- ✅ `third_cumulant_contraction(theta)`: Third derivatives of ψ
- ✅ `constraint_hessian(theta)`: ∇²C for marginal entropy constraint
- ✅ `lagrange_multiplier_gradient(theta)`: Gradient of ν(θ)
- ✅ `jacobian(theta)`: Full flow Jacobian M = -G - (∇G)[θ] + ν∇²C + a(∇ν)ᵀ

**In `qig.pair_operators`:**
- ✅ `gell_mann_generators(d)`: Gell-Mann matrices for su(d)
- ✅ `pair_basis_generators(d)`: su(d²) generators for entangled pairs
- ✅ `bell_state_density_matrix(d)`: Maximally entangled state

**In `qig.duhamel`:**
- ✅ `duhamel_derivative()`: High-precision Kubo-Mori derivative ∂ρ/∂θ

**In `qig.dynamics`:**
- ✅ `InaccessibleGameDynamics`: Time integration infrastructure

### What Needs to be Implemented

**Phase 1: Lie Algebra Structure**

1. **Structure constants module** (`qig/structure_constants.py`):
   - Compute structure constants f_abc for su(d): [F_a, F_b] = 2i Σ_c f_abc F_c
   - Cache structure constants for common dimensions (d=2,3)
   - Verify Jacobi identity for computed structure constants
   - For tensor product bases (local operators on different sites), handle f_abc = 0 when operators act on different sites

2. **Lie algebra utilities**:
   - `compute_structure_constants(operators)`: Given basis {F_a}, compute all f_abc
   - `verify_lie_algebra(operators, f_abc)`: Check commutation relations
   - `verify_jacobi_identity(f_abc)`: Verify Jacobi identity [F_a, [F_b, F_c]] + cyclic = 0

**Phase 2: GENERIC Decomposition**

3. **Symmetric/antisymmetric decomposition** (add to `QuantumExponentialFamily`):
   - `symmetric_part(theta)`: S = ½(M + Mᵀ)
   - `antisymmetric_part(theta)`: A = ½(M - Mᵀ)
   - `verify_degeneracy_conditions(theta)`: Check Sa ≈ 0 and A(-Gθ) ≈ 0

**Phase 3: Effective Hamiltonian Extraction**

4. **Hamiltonian extraction** (`qig/generic.py` - new module):
   - `effective_hamiltonian_coefficients(A, theta, f_abc)`: 
     - Solve A_ab θ_b = Σ_c f_abc η_c for coefficients {η_a}
     - Return η vector
   - `effective_hamiltonian_operator(eta, operators)`:
     - Construct H_eff = Σ_a η_a F_a as matrix
   - `verify_hamiltonian_evolution(H_eff, A, theta)`:
     - Check that -i[H_eff, ρ] matches A-generated flow

**Phase 4: Diffusion Operator**

5. **Diffusion operator construction**:
   - `diffusion_operator(S, theta, rho)`:
     - Compute dissipative flow in density matrix space
     - Use Kubo-Mori derivatives from `duhamel` module
     - Map natural parameter flow S⋅q to density matrix flow
   - `milburn_approximation(H_eff, gamma)`:
     - Near equilibrium: D[ρ] ≈ -½γ[H_eff, [H_eff, ρ]]
     - Compute effective decoherence rate γ

**Phase 5: Full Dynamics Integration**

6. **Complete GENERIC dynamics**:
   - `GenericDynamics` class (extends or wraps `InaccessibleGameDynamics`):
     - Tracks both H_eff and D[ρ] throughout evolution
     - Computes entropy production rate from S
     - Monitors GENERIC structure preservation
   - Integration methods:
     - `integrate_generic(t_span, theta0)`: Full dynamics
     - `integrate_reversible(t_span, theta0)`: Unitary part only
     - `integrate_irreversible(t_span, theta0)`: Dissipative part only

**Phase 6: GENERIC Decomposition Orchestration**

7. **High-level interface** (`qig/generic_decomposition.py`):
   - `GenericDecomposition` class:
     - Takes a state θ on constraint manifold
     - Executes all 12 steps systematically
     - Returns comprehensive results with diagnostics
   - `run_generic_decomposition(theta, exp_fam, **options)`:
     - Convenience function for complete computation
     - Returns dict with all intermediate results
   - Validation and diagnostics:
     - Check Hermiticity, tracelessness, orthogonality
     - Verify constraint satisfaction
     - Check GENERIC structure conditions
     - Monitor numerical precision

### Module Structure

```
qig/
├── structure_constants.py      # NEW: Lie algebra structure constants
├── generic.py                   # NEW: GENERIC decomposition tools
├── generic_decomposition.py    # NEW: Orchestration and diagnostics
├── exponential_family.py        # EXTEND: Add S/A decomposition methods
├── dynamics.py                  # EXTEND: Add GENERIC-aware dynamics
├── duhamel.py                   # EXISTS: Kubo-Mori derivatives
├── pair_operators.py            # EXISTS: Operator bases
└── core.py                      # EXISTS: Basic utilities
```

## Implementation Plan

### Phase 0: Validation Infrastructure (1 day)

**Create validation utilities first** to enable test-driven development:

1. **Create `qig/validation.py`**:
   - [ ] Implement `compare_matrices(A, B, tol, name)`: Smart matrix comparison with diagnostics
   - [ ] Implement `check_hermitian(M, tol)`: Verify Hermiticity
   - [ ] Implement `check_traceless(M, tol)`: Verify tracelessness  
   - [ ] Implement `check_commutator(A, B, C, f_abc, tol)`: Verify [A,B] = 2i Σ f_abc C
   - [ ] Implement `finite_difference_jacobian(func, x, eps)`: Generic FD for validation
   - [ ] Implement `ValidationReport` class: Collects and pretty-prints all checks

2. **Create reference data**:
   - [ ] Generate and save known SU(2) structure constants
   - [ ] Generate and save known SU(3) structure constants
   - [ ] Document source/reference for all reference data

This infrastructure will be used throughout all subsequent phases.

### Phase 1: Lie Algebra Structure (2-3 days)

1. **Create `qig/structure_constants.py`**:
   - [ ] Implement `compute_structure_constants(operators, tol=1e-10)`
     - For each pair (a,b), compute [F_a, F_b]
     - Decompose commutator in basis: [F_a, F_b] = Σ_c c_abc F_c
     - Extract structure constants (with normalization convention)
   - [ ] Implement `verify_lie_algebra(operators, f_abc, tol=1e-8)`
     - Check [F_a, F_b] = 2i Σ_c f_abc F_c
   - [ ] Implement `verify_jacobi_identity(f_abc, tol=1e-8)`
     - Check Σ_c (f_abc f_cde + f_bdc f_cae + f_dac f_cbe) = 0
   - [ ] Cache for common cases:
     - `SU2_STRUCTURE_CONSTANTS`: Pauli matrices
     - `SU3_STRUCTURE_CONSTANTS`: Gell-Mann matrices
   - [ ] Tests: `test_structure_constants.py`
     - Verify su(2) structure constants match Pauli algebra
     - Verify su(3) structure constants match standard tables
     - Test Jacobi identity for d=2,3
     - Test tensor product handling (operators on different sites commute)

2. **Test with existing operator bases** (test-driven):
   - [ ] **First**: Write tests with expected behavior
   - [ ] Compute f_abc for Pauli basis (2 qubits)
   - [ ] **Cross-validate**: Compare with reference SU(2) structure constants
   - [ ] Compute f_abc for Gell-Mann basis (2 qutrits)
   - [ ] **Cross-validate**: Compare with reference SU(3) structure constants
   - [ ] Verify Jacobi identity holds numerically
   - [ ] **Cross-validate**: Test commutators directly vs structure constant formula
   - [ ] Document any numerical tolerance issues

### Phase 2: GENERIC Decomposition (2-3 days)

3. **Extend `QuantumExponentialFamily`** (test-driven):
   - [ ] **First**: Write tests for expected properties
   - [ ] Add `symmetric_part(self, theta)` method
     - M = self.jacobian(theta)
     - Return S = 0.5 * (M + M.T)
     - **Validate**: S == S.T with tol ~10^-14
     - **Validate**: M == S + A reconstruction
   - [ ] Add `antisymmetric_part(self, theta)` method
     - M = self.jacobian(theta)
     - Return A = 0.5 * (M - M.T)
     - **Validate**: A == -A.T with tol ~10^-14
   - [ ] Add `verify_degeneracy_conditions(self, theta, tol=1e-6)` method
     - Compute constraint gradient a = ∇C
     - Compute entropy gradient ∇H = -G⋅θ
     - **Validate**: ||Sa|| < tol (S annihilates constraint)
     - **Validate**: ||A(∇H)|| < tol (A annihilates entropy gradient)
     - **Physical check**: θ^T S θ ≥ 0 (entropy production)
     - Return comprehensive diagnostics dict

4. **Add explicit GENERIC decomposition example**:
   - [ ] Create `examples/generic_decomposition.py` script
   - [ ] Initialize 2-qutrit system near LME origin
   - [ ] Compute M, S, A
   - [ ] Verify symmetry properties
   - [ ] Verify degeneracy conditions
   - [ ] Plot eigenvalue structure of S and A

### Phase 3: Effective Hamiltonian (3-4 days)

5. **Create `qig/generic.py` module** (test-driven):
   - [ ] **First**: Write tests with known solutions (Werner state, etc.)
   - [ ] Implement `effective_hamiltonian_coefficients(A, theta, f_abc)`
     - **Method A**: Construct matrix F with F_rc = Σ_b f_rbc θ_b
     - Compute vector v = A⋅θ
     - Solve linear system F⋅η = v for η
     - Handle near-singular cases (regularization if needed)
     - Return η coefficients with condition number diagnostic
   - [ ] Implement `effective_hamiltonian_coefficients_lstsq(A, theta, operators, rho)`
     - **Method B**: Least-squares fitting approach
     - Minimize ||i[H_eff, ρ] - ρ_dot_reversible||
     - Return η coefficients
   - [ ] **Cross-validate**: Compare Method A and Method B, ensure ||η_A - η_B|| < 10^-6
   - [ ] Implement `effective_hamiltonian_operator(eta, operators)`
     - Return H_eff = Σ_a η_a F_a as matrix
     - **Validate**: H_eff == H_eff^† (Hermiticity) with tol ~10^-12
     - **Validate**: Tr(H_eff) ≈ 0 (traceless) with tol ~10^-10
   - [ ] Implement `verify_hamiltonian_evolution(H_eff, A, theta, rho, tol=1e-6)`
     - Compute -i[H_eff, ρ] in density matrix space
     - Map A to density matrix flow
     - Compare and return error norm
     - **Validate**: Energy conservation d/dt Tr(H_eff ρ) ≈ 0

6. **Tests**:
   - [ ] `test_generic_hamiltonian.py`
     - Test extraction for 2-qubit system (known su(2) structure)
     - Test extraction for 2-qutrit system
     - Verify Hermiticity of H_eff
     - Verify commutator evolution matches A
     - Test near-origin where degeneracy is maximal

### Phase 4: Diffusion Operator (3-4 days)

7. **Extend `qig/generic.py`**:
   - [ ] Implement `kubo_mori_derivatives(theta, operators, exp_fam)`
     - For each F_a, compute ∂ρ/∂θ_a using Duhamel formula
     - Return list of ∂_a ρ matrices
   - [ ] Implement `diffusion_operator(S, theta, exp_fam)`
     - Get Kubo-Mori derivatives ∂_a ρ
     - Compute mean parameters q (tangent to constraint)
     - Compute dissipative flow: D[ρ] = Σ_a (S⋅q)_a ∂_a ρ
     - Return D[ρ] as matrix
   - [ ] Implement `milburn_approximation(H_eff, gamma=1.0)`
     - Return -0.5 * gamma * commutator(H_eff, commutator(H_eff, rho))
     - Useful for comparison near equilibrium

8. **Tests**:
   - [ ] `test_diffusion_operator.py`
     - Test Kubo-Mori derivatives match duhamel module output
     - Verify D[ρ] is Hermitian
     - Verify Tr(D[ρ]) = 0 (trace preservation)
     - Check entropy production: dS/dt = -Tr(ρ log ρ D[ρ]) ≥ 0
     - Compare with Milburn form near equilibrium

### Phase 5: Complete Dynamics (2-3 days)

9. **Extend `qig/dynamics.py`**:
   - [ ] Add `GenericDynamics` class or extend `InaccessibleGameDynamics`
     - Store H_eff and D[ρ] alongside trajectory
     - Compute both at each integration step
     - Track entropy production rate
     - Monitor preservation of GENERIC structure
   - [ ] Add integration methods:
     - `integrate_generic(t_span, theta0)`: Full ρ̇ = -i[H_eff,ρ] + D[ρ]
     - `integrate_reversible(t_span, theta0)`: Unitary only
     - `integrate_irreversible(t_span, theta0)`: Dissipative only
   - [ ] Add diagnostics:
     - Track ||S|| and ||A|| over time
     - Monitor degeneracy condition violations
     - Compute cumulative entropy production

10. **Tests**:
    - [ ] `test_generic_dynamics.py`
      - Integrate full GENERIC dynamics for 2-qubit system
      - Compare reversible + irreversible vs full dynamics
      - Verify constraint preservation
      - Verify entropy monotonicity
      - Check energy conservation for reversible part
      - Check entropy production for irreversible part

### Phase 6: GENERIC Decomposition Interface (2-3 days)

11. **Create `qig/generic_decomposition.py`**:
    - [ ] Implement `GenericDecomposition` class:
      ```python
      class GenericDecomposition:
          def __init__(self, exp_fam: QuantumExponentialFamily):
              self.exp_fam = exp_fam
              self.results = {}
              
          def compute_all(self, theta: np.ndarray) -> dict:
              """Execute all 12 steps and return comprehensive results."""
              # Step 0: Initial state
              self.results['theta'] = theta
              self.results['rho'] = self.exp_fam.rho_from_theta(theta)
              
              # Steps 1-8: Information geometry
              self.results['psi'] = self.exp_fam.psi(theta)
              self.results['mu'] = self.exp_fam._grad_psi(theta)
              self.results['G'] = self.exp_fam.fisher_information(theta)
              self.results['marginal_entropies'] = self._marginal_entropies(theta)
              self.results['constraint_gradient'] = self._constraint_gradient(theta)
              self.results['nu'] = self._lagrange_multiplier(theta)
              self.results['grad_nu'] = self.exp_fam.lagrange_multiplier_gradient(theta)
              self.results['M'] = self.exp_fam.jacobian(theta)
              
              # Step 9: Decomposition
              self.results['S'] = self.exp_fam.symmetric_part(theta)
              self.results['A'] = self.exp_fam.antisymmetric_part(theta)
              
              # Step 10: Hamiltonian
              f_abc = compute_structure_constants(self.exp_fam.operators)
              eta = effective_hamiltonian_coefficients(
                  self.results['A'], theta, f_abc
              )
              self.results['eta'] = eta
              self.results['H_eff'] = effective_hamiltonian_operator(
                  eta, self.exp_fam.operators
              )
              
              # Step 11: Diffusion
              self.results['D'] = diffusion_operator(
                  self.results['S'], theta, self.exp_fam
              )
              
              # Step 12: Diagnostics
              self.results['diagnostics'] = self._compute_diagnostics()
              
              return self.results
              
          def _compute_diagnostics(self) -> dict:
              """Comprehensive validation checks."""
              # ... verification of all GENERIC properties
      ```
    - [ ] Implement `run_generic_decomposition(theta, exp_fam, **options)`
      - Convenience wrapper
      - Options for which steps to compute
      - Options for diagnostic level
    - [ ] Add pretty printing and visualization:
      - `print_summary()`: Human-readable results
      - `plot_decomposition()`: Visualize S and A
      - `plot_operators()`: Visualize H_eff and D[ρ]

12. **Documentation and examples**:
    - [ ] Create `examples/generic_decomposition_qutrit.py`:
      - Reproduce exact calculation from LaTeX document
      - 2-qutrit system (16 parameters)
      - Start near LME origin
      - Print all 12 steps with intermediate results
      - Verify against expected structure
    - [ ] Create `examples/generic_decomposition_qubit_pair.py`:
      - Simpler case: 2-qubit entangled pair (15 parameters with pair basis)
      - Show complete GENERIC decomposition
      - Integrate dynamics and plot trajectories
    - [ ] Update documentation:
      - Add GENERIC decomposition section to user guide
      - Document GENERIC decomposition API
      - Add theory section on Lie-algebraic structure

### Phase 7: Testing and Validation (2-3 days)

13. **Comprehensive test suite**:
    - [ ] `test_generic_decomposition_integration.py`:
      - End-to-end test for 2-qubit system
      - End-to-end test for 2-qutrit system
      - Verify all GENERIC properties
      - Regression tests against known results
    - [ ] Numerical precision tests:
      - Test near pure-state boundary (small ε)
      - Test different regularization levels
      - Document numerical stability limits
    - [ ] Property-based tests:
      - GENERIC structure preserved throughout integration
      - Entropy monotonicity
      - Constraint preservation

14. **Validation against paper**:
    - [ ] Verify qutrit optimality analysis uses correct GENERIC decomposition
    - [ ] Check that entropy gradient factor R matches theoretical prediction
    - [ ] Validate that single-pair analysis extends to multi-pair (Appendix structure)

### Phase 8: Documentation and Cleanup (1-2 days)

15. **Documentation**:
    - [ ] Docstrings for all new functions and classes
    - [ ] Mathematical descriptions in LaTeX
    - [ ] Usage examples in docstrings
    - [ ] Theory section in Sphinx docs explaining GENERIC decomposition

16. **Code review and polish**:
    - [ ] Code review of all new modules
    - [ ] Performance profiling and optimization
    - [ ] Clean up any debugging code
    - [ ] Ensure consistent British English spelling

## Backward Compatibility

This CIP is purely additive and maintains full backward compatibility:

- **No changes** to existing API of `QuantumExponentialFamily`, `InaccessibleGameDynamics`
- **New modules** (`structure_constants`, `generic`, `generic_decomposition`) are independent
- **New methods** added to existing classes are optional
- **Existing tests** continue to pass
- **Existing examples and scripts** continue to work

Users can adopt the GENERIC decomposition functionality incrementally without modifying existing code.

## Testing Strategy

### Validation Principles

Given the complexity of the analytic procedures, we adopt a **multi-method cross-validation** approach:

1. **Compare multiple computational methods** for the same quantity
2. **Check mathematical properties** (symmetries, identities, bounds)
3. **Verify against known analytical solutions** for simple cases
4. **Use numerical differentiation** as independent validation
5. **Monitor physical constraints** throughout

### Cross-Validation Tests

For each major computational step, implement multiple independent methods:

#### 1. Structure Constants Validation

**Method A: Direct commutator**
```python
# [F_a, F_b] = 2i Σ_c f_abc F_c
commutator = F_a @ F_b - F_b @ F_a
```

**Method B: Decompose in basis**
```python
# Project commutator onto each basis element
f_abc = Tr(commutator @ F_c) / Tr(F_c @ F_c)
```

**Validation checks:**
- [ ] Jacobi identity: Σ_c (f_abc f_cde + cyclic permutations) ≈ 0
- [ ] Antisymmetry: f_abc = -f_bac
- [ ] Compare with known values for su(2) and su(3)
- [ ] Commutators on different sites: f_abc = 0 when operators don't overlap

#### 2. Symmetric/Antisymmetric Decomposition

**Method A: Direct formula**
```python
S = 0.5 * (M + M.T)
A = 0.5 * (M - M.T)
```

**Validation checks:**
- [ ] S == S.T (symmetric) with tolerance ~10^-14
- [ ] A == -A.T (antisymmetric) with tolerance ~10^-14
- [ ] M == S + A (reconstruction) with tolerance ~10^-14
- [ ] ||Sa|| < tol (degeneracy: S annihilates constraint gradient)
- [ ] ||A(-Gθ)|| < tol (degeneracy: A annihilates entropy gradient)

**Physical checks:**
- [ ] Entropy production: θ^T S θ ≥ 0 (S positive semidefinite on tangent space)
- [ ] Energy conservation: Tr(A) ≈ 0 (volume preservation)

#### 3. Effective Hamiltonian Extraction

**Method A: Solve linear system**
```python
# A_ab θ_b = Σ_c f_abc η_c
# Construct F_rc = Σ_b f_rbc θ_b
# Solve F @ η = A @ θ
eta = np.linalg.solve(F, A @ theta)
```

**Method B: Direct commutator fitting**
```python
# Minimize ||i[H_eff, ρ] - ρ_dot_reversible||
# where ρ_dot_reversible comes from A
eta_fit = least_squares_fit(...)
```

**Method C: Eigenvalue evolution (for small systems)**
```python
# Track eigenvalue phases under unitary evolution
# H_eff eigenvectors should match ρ eigenvectors
```

**Validation checks:**
- [ ] H_eff == H_eff^† (Hermiticity) with tolerance ~10^-12
- [ ] Tr(H_eff) ≈ 0 (traceless for Lie algebra)
- [ ] Compare -i[H_eff, ρ] with A-generated flow: error < 10^-8
- [ ] Energy conservation: d/dt Tr(H_eff ρ) ≈ 0 for unitary part
- [ ] Compare Method A and Method B: ||η_A - η_B|| < 10^-6

**Known solutions for validation:**
- [ ] **Two-qubit Werner state**: Known H_eff = Σ_i J_i σ_i^(1) ⊗ σ_i^(2)
- [ ] **Isotropic state**: Symmetric H_eff under qubit exchange
- [ ] **Product state**: H_eff should be sum of local Hamiltonians

#### 4. Diffusion Operator

**Method A: Kubo-Mori flow**
```python
# D[ρ] = Σ_a (S @ q)_a * ∂_a ρ
# where ∂_a ρ is Kubo-Mori derivative
D_rho = sum((S @ q)[a] * duhamel_derivative(theta, a) 
            for a in range(n_params))
```

**Method B: Milburn approximation (near equilibrium)**
```python
# D[ρ] ≈ -γ/2 [H_eff, [H_eff, ρ]]
D_rho_milburn = -gamma/2 * double_commutator(H_eff, rho)
```

**Method C: Lindblad form (if applicable)**
```python
# D[ρ] = Σ_k γ_k (L_k ρ L_k^† - 1/2{L_k^† L_k, ρ})
# Extract jump operators L_k from S
```

**Validation checks:**
- [ ] D[ρ] == D[ρ]^† (Hermiticity) with tolerance ~10^-10
- [ ] Tr(D[ρ]) ≈ 0 (trace preservation) with tolerance ~10^-12
- [ ] Entropy production: -Tr(ρ log ρ D[ρ]) ≥ -10^-14 (non-negative, allowing small numerical error)
- [ ] Compare Methods A and B near equilibrium: relative error < 10^-4
- [ ] Positivity preservation: eigenvalues of ρ + ε D[ρ] all ≥ 0 for small ε

**Physical checks:**
- [ ] Approach to equilibrium: D[ρ_eq] ≈ 0 at stationary state
- [ ] Detailed balance (if applicable): ρ_eq D[ρ] ρ_eq^{-1} = -D[ρ]

#### 5. Full Jacobian Validation

**Method A: Analytic formula (already implemented)**
```python
M = -G - nabla_G_theta + nu * nabla2_C + outer(a, grad_nu)
```

**Method B: Finite differences**
```python
M_fd[i,j] = (flow(theta + eps*e_j)[i] - flow(theta)[i]) / eps
```

**Method C: Automatic differentiation**
```python
M_autodiff = jacobian(lambda th: flow_vector(th), theta)
```

**Validation checks:**
- [ ] Compare analytic vs finite differences: max error < 10^-5
- [ ] Compare analytic vs autodiff: max error < 10^-8
- [ ] Constraint tangency: M @ a ≈ 0 (flow stays on manifold)
- [ ] Entropy monotonicity: θ^T M θ ≤ 10^-12 (allowing small numerical error)

### Unit Tests

Each new module will have comprehensive unit tests:

1. **`test_structure_constants.py`** (~10 tests):
   - Verify su(2) structure constants
   - Verify su(3) structure constants
   - Test Jacobi identity for various dimensions
   - Test tensor product structure
   - Test caching and performance

2. **`test_generic_decomposition.py`** (~8 tests):
   - Test S = S^T and A = -A^T
   - Test M = S + A reconstruction
   - Test degeneracy conditions near origin
   - Test degeneracy conditions away from origin

3. **`test_generic_hamiltonian.py`** (~15 tests):
   - Test coefficient extraction for su(2)
   - Test coefficient extraction for su(3)
   - Verify H_eff Hermiticity
   - Verify commutator evolution matches A
   - Test near-singular cases
   - **Cross-validation**: Compare linear solver vs least-squares fitting
   - **Known solutions**: Werner state, isotropic state, product state
   - **Symmetry checks**: Verify permutation symmetry when applicable
   - Energy conservation under unitary evolution
   - Tracelessness of H_eff

4. **`test_diffusion_operator.py`** (~12 tests):
   - Test Kubo-Mori derivative computation
   - Verify D[ρ] Hermiticity
   - Verify trace preservation
   - Verify entropy production ≥ 0
   - **Cross-validation**: Compare Kubo-Mori vs Milburn near equilibrium
   - **Cross-validation**: Compare with Lindblad form when applicable
   - Positivity preservation check
   - Approach to equilibrium: D[ρ_eq] ≈ 0
   - Test different distance from equilibrium
   - Detailed balance verification (when applicable)

5. **`test_generic_dynamics.py`** (~12 tests):
   - Test full GENERIC integration
   - Test reversible vs irreversible separation
   - Verify constraint preservation
   - Verify entropy monotonicity
   - Test different time parametrizations

6. **`test_generic_decomposition_integration.py`** (~20 tests):
   - End-to-end for 2 qubits
   - End-to-end for 2 qutrits
   - Verify all 12 steps produce valid results
   - Regression against known numerical values
   - Test different initial states
   - **Cross-validation**: Compare reversible + irreversible vs full dynamics
   - **Consistency**: Verify all intermediate quantities satisfy mathematical properties
   - **Physical constraints**: Check throughout entire procedure
   - Test at different points on constraint manifold
   - Numerical stability tests near pure-state boundary

**Total: ~73 new tests**, all with clear tolerances documented.

### Regression Test Suite

Create a reference database of known-good results:

```python
# tests/reference_data/
├── su2_structure_constants.npy       # Known SU(2) structure constants
├── su3_structure_constants.npy       # Known SU(3) structure constants
├── two_qubit_generic_decomp.pkl      # Complete decomposition for 2 qubits
├── two_qutrit_generic_decomp.pkl     # Complete decomposition for 2 qutrits
└── werner_state_hamiltonian.npy      # Analytical H_eff for Werner state
```

**Regression tests:**
- [ ] Load reference data
- [ ] Run computation with same parameters
- [ ] Compare all intermediate results
- [ ] Flag if any quantity differs by > tolerance
- [ ] Document expected changes when improving precision

### Integration Tests

1. **Reproduce LaTeX document calculations**:
   - Run `examples/generic_decomposition_qutrit.py`
   - Verify all intermediate results match theoretical expectations
   - Check numerical values against hand calculations
   - **Cross-validate**: Run same calculation with multiple methods
   - Document all tolerance thresholds used

2. **Known analytical solutions**:
   - **Two-qubit Werner state**: ρ = p|ψ⟩⟨ψ| + (1-p)I/4
     - Compute H_eff analytically
     - Compare with numerical extraction: error < 10^-6
   - **Harmonic oscillator (if applicable)**:
     - Known H_eff = ω(a^†a + 1/2)
     - Verify GENERIC structure matches theory
   - **Product states**:
     - H_eff should be sum of local Hamiltonians
     - Cross-pair coupling should be zero

3. **Validation against paper claims**:
   - Verify GENERIC decomposition at LME origin
   - Check qutrit optimality through GENERIC decomposition
   - Validate entropy gradient factor R
   - **Cross-validate** with finite differences where possible

### Numerical Precision

**Tolerance hierarchy** (from most to least strict):

| Quantity | Expected Tolerance | Validation Method |
|----------|-------------------|-------------------|
| Symmetry (S = S^T, A = -A^T) | ~10^-14 | Machine precision |
| Hermiticity (H_eff = H_eff^†) | ~10^-12 | Direct computation |
| Trace preservation (Tr(D[ρ])) | ~10^-12 | Direct computation |
| Structure constants (vs known) | ~10^-10 | Compare to references |
| Jacobi identity | ~10^-8 | Triple sum of structure constants |
| Analytic vs autodiff Jacobian | ~10^-8 | Cross-validation |
| Degeneracy conditions (Sa, A∇H) | ~10^-6 | Numerical derivatives in constraint |
| Commutator matching (-i[H,ρ] vs A-flow) | ~10^-6 | Kubo-Mori transformation |
| Analytic vs finite-diff Jacobian | ~10^-5 | Finite difference accuracy |
| Milburn vs Kubo-Mori (near eq.) | ~10^-4 | Different approximations |

**Regularization tests:**
- Test with ε = 10^-3, 10^-4, 10^-5, 10^-6, 10^-7, 10^-8
- Document which quantities become unstable at each level
- Provide recommended ε for typical use cases
- Profile numerical stability near pure-state boundary
- Provide guidance on precision vs. performance tradeoffs

**Adaptive tolerance:**
- Implement `check_consistency()` function that adjusts tolerances based on system state
- Near pure states: relax tolerances for near-zero eigenvalues
- Far from origin: use stricter tolerances

### Performance

- Profile computation time for typical cases (n=2, d=2,3)
- Identify bottlenecks (likely: structure constants, Jacobian)
- Document scaling with system size
- Optimize critical paths if needed

## Related Requirements

This CIP addresses several core requirements from the quantum inaccessible game project:

### From LaTeX Document (`handle-turning-example.tex`)

- **Complete computational procedure**: Implements systematic 12-step decomposition explicitly
- **Lie-algebraic structure**: Uses Gell-Mann generators and structure constants
- **GENERIC decomposition**: Separates reversible and irreversible dynamics
- **Single-pair analysis**: Supports both single pair and multi-pair systems

### From Project Goals

- **Numerical validation**: Provides tools to validate theoretical predictions
- **Qutrit optimality**: Enables computation of entropy gradient factor R
- **Reproducibility**: Makes paper calculations explicit and runnable
- **Extensibility**: Framework for exploring different dimensions and constraints

### Related to Existing CIPs

- **CIP-0001**: Builds on refactored module structure
- **CIP-0002**: May utilize advanced analysis tools
- **CIP-0003**: Complements dynamics infrastructure
- **CIP-0004**: Follows test tolerance framework
- **CIP-0005**: Will be documented in Sphinx

## Implementation Status

### Phase 0: Validation Infrastructure
- [ ] Create `qig/validation.py` with comparison utilities
- [ ] Implement `ValidationReport` class
- [ ] Generate and save reference data for SU(2) and SU(3)
- [ ] Document all reference sources

### Phase 1: Lie Algebra Structure
- [ ] Create `qig/structure_constants.py`
- [ ] Implement structure constant computation
- [ ] Implement Jacobi identity verification
- [ ] Create cache for common cases
- [ ] Write tests (`test_structure_constants.py`)

### Phase 2: GENERIC Decomposition
- [ ] Add `symmetric_part()` to `QuantumExponentialFamily`
- [ ] Add `antisymmetric_part()` to `QuantumExponentialFamily`
- [ ] Add `verify_degeneracy_conditions()` to `QuantumExponentialFamily`
- [ ] Create `examples/generic_decomposition.py`

### Phase 3: Effective Hamiltonian
- [ ] Create `qig/generic.py`
- [ ] Implement `effective_hamiltonian_coefficients()`
- [ ] Implement `effective_hamiltonian_operator()`
- [ ] Implement `verify_hamiltonian_evolution()`
- [ ] Write tests (`test_generic_hamiltonian.py`)

### Phase 4: Diffusion Operator
- [ ] Implement `kubo_mori_derivatives()`
- [ ] Implement `diffusion_operator()`
- [ ] Implement `milburn_approximation()`
- [ ] Write tests (`test_diffusion_operator.py`)

### Phase 5: Complete Dynamics
- [ ] Extend `qig/dynamics.py` with GENERIC support
- [ ] Add `GenericDynamics` class
- [ ] Implement integration methods
- [ ] Write tests (`test_generic_dynamics.py`)

### Phase 6: GENERIC Decomposition Interface
- [ ] Create `qig/generic_decomposition.py`
- [ ] Implement `GenericDecomposition` class
- [ ] Implement `run_generic_decomposition()`
- [ ] Create `examples/generic_decomposition_qutrit.py`
- [ ] Create `examples/generic_decomposition_qubit_pair.py`

### Phase 7: Testing and Validation
- [ ] Write comprehensive test suite (~63 tests)
- [ ] Validate against LaTeX document
- [ ] Validate against paper claims
- [ ] Document numerical precision and tolerances

### Phase 8: Documentation
- [ ] Write docstrings for all new code
- [ ] Add theory section to Sphinx docs
- [ ] Add user guide section for GENERIC decomposition
- [ ] Update API reference

## References

### Code
- **Existing infrastructure**:
  - `qig/exponential_family.py`: Foundation for information geometry
  - `qig/pair_operators.py`: Gell-Mann generators already implemented
  - `qig/duhamel.py`: High-precision Kubo-Mori derivatives
  - `qig/dynamics.py`: Integration framework

### Documentation
- **LaTeX source**: `/Users/neil/lawrennd/the-inaccessible-game-orgin/handle-turning-example.tex`
  - Section 2: Gell-Mann generators for su(3)
  - Section 3: Complete 12-step procedure
  - Section 4: Connection to LME origin
  - Section 5: Symmetric configuration simplifications
- **Main paper**: *The Origin of the Inaccessible Game*
  - GENERIC structure theory
  - Entropy gradient factor R
  - Qutrit optimality argument

### Theory
- **GENERIC framework**: Grmela & Öttinger formalism
- **Lie-algebraic methods**: Structure constants and commutation relations
- **Quantum information geometry**: BKM metric, Kubo-Mori derivatives
- **Constrained dynamics**: Lagrange multipliers and projection

## Notes

### Computational Complexity

Expected computational costs for GENERIC decomposition procedure:

| System | Parameters | F_a dim | Structure constants | Jacobian | H_eff extraction |
|--------|-----------|---------|---------------------|----------|------------------|
| 2 qubits (local) | 6 | 4×4 | ~20 | Fast | Fast |
| 2 qubits (pair) | 15 | 4×4 | ~3,000 | Medium | Fast |
| 2 qutrits (local) | 16 | 9×9 | ~1,200 | Medium | Medium |
| 2 qutrits (pair) | 80 | 9×9 | ~500,000 | Slow | Medium |

**Bottlenecks**: Structure constant computation and Jacobian evaluation. 
**Optimization opportunities**: Cache structure constants, use sparse storage.

### Future Extensions

Potential future work building on this CIP:

1. **Analytic Jacobi identity**: Symbolic verification for special cases
2. **Efficient structure constant storage**: Sparse representation for large systems
3. **Parallel computation**: Distribute structure constant computation
4. **Adaptive precision**: Automatically adjust tolerances based on state
5. **Interactive visualization**: Real-time plotting of H_eff and D[ρ] evolution
6. **Comparison tools**: Compare GENERIC decomposition across different states

### Connection to Paper

This CIP implements the computational foundation for several paper claims:

- **Lemma 4.1**: Verified via constraint gradient at origin
- **Lemma 6.1**: Qutrit optimality via entropy gradient factor R computation
- **GENERIC decomposition**: Explicit separation validated numerically
- **Appendix structure**: Single-pair to multi-pair extensivity

Having working code strengthens all these theoretical results.

