---
author: "Neil D. Lawrence"
created: "2025-12-01"
id: "0006"
last_updated: "2025-12-01"
status: proposed
tags:
- cip
- generic
- lie-algebra
- handle-turning
- quantum-dynamics
title: "Implement GENERIC Decomposition for Lie-Algebraic Bases"
---

# CIP-0006: Implement GENERIC Decomposition for Lie-Algebraic Bases

## Summary

Implement a comprehensive computational framework for extracting GENERIC dynamics (effective Hamiltonian and diffusion operator) from the quantum inaccessible game using a Lie-algebraic operator basis. This provides a systematic procedure that decomposes the constrained information-geometric flow into reversible (Hamiltonian) and irreversible (dissipative) components.

## Motivation

The quantum inaccessible game paper establishes that the constrained dynamics on the marginal-entropy manifold can be decomposed into:

1. **Reversible part**: Hamiltonian evolution -i[H_eff, œÅ]
2. **Irreversible part**: Dissipative evolution D[œÅ]

This GENERIC-like decomposition emerges from the flow Jacobian M = A + S:
- **Antisymmetric part A**: Generates unitary evolution via H_eff
- **Symmetric part S**: Generates dissipative evolution via diffusion operator

The LaTeX document `handle-turning-example.tex` provides an explicit 12-step computational procedure for qutrits, but this is not yet implemented in the `qig` codebase. Having working code that:

1. Takes a state on the constraint manifold
2. Computes the full flow Jacobian M (already implemented in `QuantumExponentialFamily.jacobian()`)
3. Decomposes M = A + S
4. Extracts H_eff from A using Lie algebra structure constants
5. Constructs D[œÅ] from S using Kubo-Mori derivatives
6. Integrates the full dynamics

will provide:
- **Validation** of the theoretical framework
- **Numerical verification** of GENERIC structure
- **Concrete examples** for the paper
- **Tool for exploration** of different parameter regimes
- **Reference implementation** for GENERIC decomposition methodology

## Detailed Description

### What Already Exists

The `qig` package already implements most of the computational machinery:

**In `qig.exponential_family.QuantumExponentialFamily`:**
- ‚úÖ `psi(theta)`: Cumulant generating function œà(Œ∏)
- ‚úÖ `rho_from_theta(theta)`: Density matrix œÅ(Œ∏)
- ‚úÖ `_grad_psi(theta)`: Expectation parameters Œº = ‚àáœà
- ‚úÖ `fisher_information(theta)`: BKM metric G
- ‚úÖ `third_cumulant_contraction(theta)`: Third derivatives of œà
- ‚úÖ `constraint_hessian(theta)`: ‚àá¬≤C for marginal entropy constraint
- ‚úÖ `lagrange_multiplier_gradient(theta)`: Gradient of ŒΩ(Œ∏)
- ‚úÖ `jacobian(theta)`: Full flow Jacobian M = -G - (‚àáG)[Œ∏] + ŒΩ‚àá¬≤C + a(‚àáŒΩ)·µÄ

**In `qig.pair_operators`:**
- ‚úÖ `gell_mann_generators(d)`: Gell-Mann matrices for su(d)
- ‚úÖ `pair_basis_generators(d)`: su(d¬≤) generators for entangled pairs
- ‚úÖ `bell_state_density_matrix(d)`: Maximally entangled state

**In `qig.duhamel`:**
- ‚úÖ `duhamel_derivative()`: High-precision Kubo-Mori derivative ‚àÇœÅ/‚àÇŒ∏

**In `qig.dynamics`:**
- ‚úÖ `InaccessibleGameDynamics`: Time integration infrastructure

### What Needs to be Implemented

**Phase 1: Lie Algebra Structure**

1. **Structure constants module** (`qig/structure_constants.py`):
   - Compute structure constants f_abc for su(d): [F_a, F_b] = 2i Œ£_c f_abc F_c
   - Cache structure constants for common dimensions (d=2,3)
   - Verify Jacobi identity for computed structure constants
   - For tensor product bases (local operators on different sites), handle f_abc = 0 when operators act on different sites

2. **Lie algebra utilities**:
   - `compute_structure_constants(operators)`: Given basis {F_a}, compute all f_abc
   - `verify_lie_algebra(operators, f_abc)`: Check commutation relations
   - `verify_jacobi_identity(f_abc)`: Verify Jacobi identity [F_a, [F_b, F_c]] + cyclic = 0

**Phase 2: GENERIC Decomposition**

3. **Symmetric/antisymmetric decomposition** (add to `QuantumExponentialFamily`):
   - `symmetric_part(theta)`: S = ¬Ω(M + M·µÄ)
   - `antisymmetric_part(theta)`: A = ¬Ω(M - M·µÄ)
   - `verify_degeneracy_conditions(theta)`: Check Sa ‚âà 0 and A(-GŒ∏) ‚âà 0

**Phase 3: Effective Hamiltonian Extraction**

4. **Hamiltonian extraction** (`qig/generic.py` - new module):
   - `effective_hamiltonian_coefficients(A, theta, f_abc)`: 
     - Solve A_ab Œ∏_b = Œ£_c f_abc Œ∑_c for coefficients {Œ∑_a}
     - Return Œ∑ vector
   - `effective_hamiltonian_operator(eta, operators)`:
     - Construct H_eff = Œ£_a Œ∑_a F_a as matrix
   - `verify_hamiltonian_evolution(H_eff, A, theta)`:
     - Check that -i[H_eff, œÅ] matches A-generated flow

**Phase 4: Diffusion Operator**

5. **Diffusion operator construction**:
   - `diffusion_operator(S, theta, rho)`:
     - Compute dissipative flow in density matrix space
     - Use Kubo-Mori derivatives from `duhamel` module
     - Map natural parameter flow S‚ãÖq to density matrix flow
   - `milburn_approximation(H_eff, gamma)`:
     - Near equilibrium: D[œÅ] ‚âà -¬ΩŒ≥[H_eff, [H_eff, œÅ]]
     - Compute effective decoherence rate Œ≥

**Phase 5: Full Dynamics Integration**

6. **Complete GENERIC dynamics**:
   - `GenericDynamics` class (extends or wraps `InaccessibleGameDynamics`):
     - Tracks both H_eff and D[œÅ] throughout evolution
     - Computes entropy production rate from S
     - Monitors GENERIC structure preservation
   - Integration methods:
     - `integrate_generic(t_span, theta0)`: Full dynamics
     - `integrate_reversible(t_span, theta0)`: Unitary part only
     - `integrate_irreversible(t_span, theta0)`: Dissipative part only

**Phase 6: GENERIC Decomposition Orchestration**

7. **High-level interface** (`qig/generic_decomposition.py`):
   - `GenericDecomposition` class:
     - Takes a state Œ∏ on constraint manifold
     - Executes all 12 steps systematically
     - Returns comprehensive results with diagnostics
   - `run_generic_decomposition(theta, exp_fam, **options)`:
     - Convenience function for complete computation
     - Returns dict with all intermediate results
   - Validation and diagnostics:
     - Check Hermiticity, tracelessness, orthogonality
     - Verify constraint satisfaction
     - Check GENERIC structure conditions
     - Monitor numerical precision

### Module Structure

```
qig/
‚îú‚îÄ‚îÄ structure_constants.py      # NEW: Lie algebra structure constants
‚îú‚îÄ‚îÄ generic.py                   # NEW: GENERIC decomposition tools
‚îú‚îÄ‚îÄ generic_decomposition.py    # NEW: Orchestration and diagnostics
‚îú‚îÄ‚îÄ exponential_family.py        # EXTEND: Add S/A decomposition methods
‚îú‚îÄ‚îÄ dynamics.py                  # EXTEND: Add GENERIC-aware dynamics
‚îú‚îÄ‚îÄ duhamel.py                   # EXISTS: Kubo-Mori derivatives
‚îú‚îÄ‚îÄ pair_operators.py            # EXISTS: Operator bases
‚îî‚îÄ‚îÄ core.py                      # EXISTS: Basic utilities
```

## Key Distinction: When Duhamel Integrals Are Needed

### The Lie Closure Cancellation

A crucial insight from the theory (Section on "Duhamel Cancellation" in the paper, lines 988-998) is that **working in natural parameters with a Lie-closed operator basis suppresses the Duhamel integral for scalar derivatives**. This algebraic cancellation significantly simplifies the geometry.

However, this cancellation is **context-dependent**:

### ‚úÖ NO Duhamel Required (Lie closure cancels):

**For dynamics in natural parameter space Œ∏:**

1. **Computing the Jacobian M** (implemented in `QuantumExponentialFamily.jacobian()`):
   ```
   M = -G - (‚àáG)[Œ∏] + ŒΩ‚àá¬≤C + a(‚àáŒΩ)·µÄ
   ```
   - Uses third cumulant T_abc = ‚àÇ¬≥œà/‚àÇŒ∏_a‚àÇŒ∏_b‚àÇŒ∏_c
   - This is a **scalar derivative** of œà(Œ∏) = log Tr[exp(K)]
   - ‚úÖ Lie closure ensures Duhamel cancels in the natural parameter gradient

2. **Entropy gradient ‚àÇS/‚àÇŒ∏**:
   - Scalar derivative of von Neumann entropy
   - ‚úÖ Cancellation applies

3. **All flow computations in Œ∏-space**:
   - Œ∏Ãá = F(Œ∏) = -Œ†_‚à• G Œ∏
   - GENERIC decomposition M = S + A
   - Constraint enforcement
   - ‚úÖ Pure algebraic operations on scalar functions

### ‚ùå Duhamel REQUIRED (no cancellation):

**For mapping to density matrix space œÅ:**

1. **Kubo-Mori derivatives ‚àÇœÅ/‚àÇŒ∏** (implemented in `qig/duhamel.py`):
   ```
   ‚àÇœÅ/‚àÇŒ∏_a = ‚à´‚ÇÄ¬π œÅ^s (F_a - ‚ü®F_a‚ü©I) œÅ^{1-s} ds
   ```
   - This is a **matrix-valued derivative**, not a scalar
   - ‚ùå No cancellation - full Duhamel integral required

2. **Diffusion operator D[œÅ]** (Phase 4):
   ```
   D[œÅ] = Œ£_a (S‚ãÖq)_a ‚àÇœÅ/‚àÇŒ∏_a
   ```
   - Maps parameter space flow to density matrix flow
   - ‚ùå Requires Kubo-Mori derivatives

3. **Full dynamics in density matrix form**:
   ```
   œÅÃá = -i[H_eff, œÅ] + D[œÅ]
   ```
   - Master equation representation
   - ‚ùå Requires D[œÅ] which needs Duhamel

### Practical Implication for This CIP

**The quantum inaccessible game is played entirely in natural parameter space Œ∏.** Therefore:

- ‚úÖ **Core game dynamics**: NO Duhamel needed
  - Initial state: Œ∏(t=0) at LME origin
  - Flow: Œ∏Ãá = -Œ†_‚à• G Œ∏
  - GENERIC decomposition: M = S + A
  - Effective Hamiltonian extraction: Œ∑ from A
  - Endpoint detection: ||a|| ‚Üí 0

- ‚ö†Ô∏è **Duhamel only required for**:
  - Visualizing œÅ(t) (the "movie" of density matrices)
  - Computing D[œÅ] for comparison with master equations
  - Connecting to standard quantum optics formulations
  - Physical interpretation in density matrix language

**Implementation consequence**: Phases 1-3 (structure constants, GENERIC decomposition, Hamiltonian extraction) work purely in parameter space and benefit from the Lie closure simplification. Only Phase 4 (diffusion operator) requires the Duhamel machinery from `qig/duhamel.py`.

This is why the diffusion operator computation is more expensive than the Hamiltonian extraction - we lose the algebraic cancellation when mapping to density matrix space.

## Implementation Plan

### Phase Progression Strategy

**Each phase has explicit completion criteria ("phase gates")** that must be satisfied before proceeding to the next phase. This ensures:
1. ‚úÖ Solid foundation at each level
2. ‚úÖ No accumulation of technical debt
3. ‚úÖ Clear validation of correctness
4. ‚úÖ Reproducible development process

**Phase Gate Requirements:**
- All unit tests for the phase must pass
- Cross-validation tests must show agreement within tolerance
- Code review and documentation complete
- Known issues documented with workarounds or deferred to later phases

### Phase 0: Validation Infrastructure (1 day)

**üéØ Phase Goal:** Create reusable validation tools for all subsequent phases

**Create validation utilities first** to enable test-driven development:

1. **Create `qig/validation.py`**:
   - [ ] Implement `compare_matrices(A, B, tol, name)`: Smart matrix comparison with diagnostics
   - [ ] Implement `check_hermitian(M, tol)`: Verify Hermiticity
   - [ ] Implement `check_traceless(M, tol)`: Verify tracelessness  
   - [ ] Implement `check_commutator(A, B, C, f_abc, tol)`: Verify [A,B] = 2i Œ£ f_abc C
   - [ ] Implement `finite_difference_jacobian(func, x, eps)`: Generic FD for validation
   - [ ] Implement `ValidationReport` class: Collects and pretty-prints all checks

2. **Create reference data**:
   - [ ] Generate and save known SU(2) structure constants
   - [ ] Generate and save known SU(3) structure constants
   - [ ] Document source/reference for all reference data

This infrastructure will be used throughout all subsequent phases.

**‚úÖ Phase 0 Completion Criteria (Gate to Phase 1):**
- [ ] All validation utilities implemented and tested
- [ ] `ValidationReport` class produces readable output
- [ ] Reference data for SU(2) structure constants verified against literature
- [ ] Reference data for SU(3) structure constants verified against literature
- [ ] All comparison functions handle edge cases (NaN, Inf, near-zero values)
- [ ] Documentation for validation module complete

### Phase 1: Lie Algebra Structure (2-3 days)

**üéØ Phase Goal:** Compute and verify Lie algebra structure constants

1. **Create `qig/structure_constants.py`**:
   - [ ] Implement `compute_structure_constants(operators, tol=1e-10)`
     - For each pair (a,b), compute [F_a, F_b]
     - Decompose commutator in basis: [F_a, F_b] = Œ£_c c_abc F_c
     - Extract structure constants (with normalization convention)
   - [ ] Implement `verify_lie_algebra(operators, f_abc, tol=1e-8)`
     - Check [F_a, F_b] = 2i Œ£_c f_abc F_c
   - [ ] Implement `verify_jacobi_identity(f_abc, tol=1e-8)`
     - Check Œ£_c (f_abc f_cde + f_bdc f_cae + f_dac f_cbe) = 0
   - [ ] Cache for common cases:
     - `SU2_STRUCTURE_CONSTANTS`: Pauli matrices
     - `SU3_STRUCTURE_CONSTANTS`: Gell-Mann matrices
   - [ ] Tests: `test_structure_constants.py`
     - Verify su(2) structure constants match Pauli algebra
     - Verify su(3) structure constants match standard tables
     - Test Jacobi identity for d=2,3
     - Test tensor product handling (operators on different sites commute)

2. **Test with existing operator bases** (test-driven):
   - [ ] **First**: Write tests with expected behavior
   - [ ] Compute f_abc for Pauli basis (2 qubits)
   - [ ] **Cross-validate**: Compare with reference SU(2) structure constants
   - [ ] Compute f_abc for Gell-Mann basis (2 qutrits)
   - [ ] **Cross-validate**: Compare with reference SU(3) structure constants
   - [ ] Verify Jacobi identity holds numerically
   - [ ] **Cross-validate**: Test commutators directly vs structure constant formula
   - [ ] Document any numerical tolerance issues

**‚úÖ Phase 1 Completion Criteria (Gate to Phase 2):**
- [ ] All tests in `test_structure_constants.py` pass (~10 tests)
- [ ] SU(2) structure constants match reference: max error < 10^-10
- [ ] SU(3) structure constants match reference: max error < 10^-10
- [ ] Jacobi identity verified for d=2,3: max violation < 10^-8
- [ ] Tensor product structure verified (operators on different sites commute)
- [ ] Caching mechanism works correctly
- [ ] Documentation complete with examples

### Phase 2: GENERIC Decomposition (2-3 days)

**üéØ Phase Goal:** Implement symmetric/antisymmetric decomposition of flow Jacobian

3. **Extend `QuantumExponentialFamily`** (test-driven):
   - [ ] **First**: Write tests for expected properties
   - [ ] Add `symmetric_part(self, theta)` method
     - M = self.jacobian(theta)
     - Return S = 0.5 * (M + M.T)
     - **Validate**: S == S.T with tol ~10^-14
     - **Validate**: M == S + A reconstruction
   - [ ] Add `antisymmetric_part(self, theta)` method
     - M = self.jacobian(theta)
     - Return A = 0.5 * (M - M.T)
     - **Validate**: A == -A.T with tol ~10^-14
   - [ ] Add `verify_degeneracy_conditions(self, theta, tol=1e-6)` method
     - Compute constraint gradient a = ‚àáC
     - Compute entropy gradient ‚àáH = -G‚ãÖŒ∏
     - **Validate**: ||Sa|| < tol (S annihilates constraint)
     - **Validate**: ||A(‚àáH)|| < tol (A annihilates entropy gradient)
     - **Physical check**: Œ∏^T S Œ∏ ‚â• 0 (entropy production)
     - Return comprehensive diagnostics dict

4. **Add explicit GENERIC decomposition example**:
   - [ ] Create `examples/generic_decomposition.py` script
   - [ ] Initialize 2-qutrit system near LME origin
   - [ ] Compute M, S, A
   - [ ] Verify symmetry properties
   - [ ] Verify degeneracy conditions
   - [ ] Plot eigenvalue structure of S and A

**‚úÖ Phase 2 Completion Criteria (Gate to Phase 3):**
- [ ] All tests in `test_generic_decomposition.py` pass (~8 tests)
- [ ] Symmetry properties verified: ||S - S^T|| < 10^-14 and ||A + A^T|| < 10^-14
- [ ] Reconstruction verified: ||M - (S + A)|| < 10^-14
- [ ] Degeneracy conditions verified at test points: ||Sa|| < 10^-6, ||A(‚àáH)|| < 10^-6
- [ ] Entropy production non-negative: Œ∏^T S Œ∏ ‚â• -10^-14
- [ ] Example script `generic_decomposition.py` runs successfully
- [ ] Documentation complete with mathematical descriptions

### Phase 3: Effective Hamiltonian (3-4 days)

5. **Create `qig/generic.py` module** (test-driven):
   - [ ] **First**: Write tests with known solutions (Werner state, etc.)
   - [ ] Implement `effective_hamiltonian_coefficients(A, theta, f_abc)`
     - **Method A**: Construct matrix F with F_rc = Œ£_b f_rbc Œ∏_b
     - Compute vector v = A‚ãÖŒ∏
     - Solve linear system F‚ãÖŒ∑ = v for Œ∑
     - Handle near-singular cases (regularization if needed)
     - Return Œ∑ coefficients with condition number diagnostic
   - [ ] Implement `effective_hamiltonian_coefficients_lstsq(A, theta, operators, rho)`
     - **Method B**: Least-squares fitting approach
     - Minimize ||i[H_eff, œÅ] - œÅ_dot_reversible||
     - Return Œ∑ coefficients
   - [ ] **Cross-validate**: Compare Method A and Method B, ensure ||Œ∑_A - Œ∑_B|| < 10^-6
   - [ ] Implement `effective_hamiltonian_operator(eta, operators)`
     - Return H_eff = Œ£_a Œ∑_a F_a as matrix
     - **Validate**: H_eff == H_eff^‚Ä† (Hermiticity) with tol ~10^-12
     - **Validate**: Tr(H_eff) ‚âà 0 (traceless) with tol ~10^-10
   - [ ] Implement `verify_hamiltonian_evolution(H_eff, A, theta, rho, tol=1e-6)`
     - Compute -i[H_eff, œÅ] in density matrix space
     - Map A to density matrix flow
     - Compare and return error norm
     - **Validate**: Energy conservation d/dt Tr(H_eff œÅ) ‚âà 0

6. **Tests**:
   - [ ] `test_generic_hamiltonian.py`
     - Test extraction for 2-qubit system (known su(2) structure)
     - Test extraction for 2-qutrit system
     - Verify Hermiticity of H_eff
     - Verify commutator evolution matches A
     - Test near-origin where degeneracy is maximal

**‚úÖ Phase 3 Completion Criteria (Gate to Phase 4):**
- [ ] All tests in `test_generic_hamiltonian.py` pass (~15 tests)
- [ ] Both extraction methods (linear solver and least-squares) implemented
- [ ] Cross-validation: ||Œ∑_method_A - Œ∑_method_B|| < 10^-6
- [ ] Hermiticity verified: ||H_eff - H_eff^‚Ä†|| < 10^-12
- [ ] Tracelessness verified: |Tr(H_eff)| < 10^-10
- [ ] Commutator matching: ||-i[H_eff,œÅ] - A_flow|| < 10^-8
- [ ] Known solutions verified (Werner state, isotropic state, product state)
- [ ] Energy conservation checked: |d/dt Tr(H_eff œÅ)| < 10^-10
- [ ] Near-singular cases handled gracefully with diagnostics
- [ ] Documentation complete with usage examples

### Phase 4: Diffusion Operator (3-4 days)

**üéØ Phase Goal:** Construct diffusion operator D[œÅ] from symmetric flow

7. **Extend `qig/generic.py`**:
   - [ ] Implement `kubo_mori_derivatives(theta, operators, exp_fam)`
     - For each F_a, compute ‚àÇœÅ/‚àÇŒ∏_a using Duhamel formula
     - Return list of ‚àÇ_a œÅ matrices
   - [ ] Implement `diffusion_operator(S, theta, exp_fam)`
     - Get Kubo-Mori derivatives ‚àÇ_a œÅ
     - Compute mean parameters q (tangent to constraint)
     - Compute dissipative flow: D[œÅ] = Œ£_a (S‚ãÖq)_a ‚àÇ_a œÅ
     - Return D[œÅ] as matrix
   - [ ] Implement `milburn_approximation(H_eff, gamma=1.0)`
     - Return -0.5 * gamma * commutator(H_eff, commutator(H_eff, rho))
     - Useful for comparison near equilibrium

8. **Tests**:
   - [ ] `test_diffusion_operator.py`
     - Test Kubo-Mori derivatives match duhamel module output
     - Verify D[œÅ] is Hermitian
     - Verify Tr(D[œÅ]) = 0 (trace preservation)
     - Check entropy production: dS/dt = -Tr(œÅ log œÅ D[œÅ]) ‚â• 0
     - Compare with Milburn form near equilibrium

**‚úÖ Phase 4 Completion Criteria (Gate to Phase 5):**
- [ ] All tests in `test_diffusion_operator.py` pass (~12 tests)
- [ ] Kubo-Mori derivatives computed correctly (match duhamel module)
- [ ] Hermiticity verified: ||D[œÅ] - D[œÅ]^‚Ä†|| < 10^-10
- [ ] Trace preservation: |Tr(D[œÅ])| < 10^-12
- [ ] Entropy production: -Tr(œÅ log œÅ D[œÅ]) ‚â• -10^-14
- [ ] Cross-validation: Kubo-Mori vs Milburn agreement < 10^-4 near equilibrium
- [ ] Positivity preservation: all eigenvalues of œÅ + Œµ D[œÅ] ‚â• -10^-14
- [ ] Approach to equilibrium: ||D[œÅ_eq]|| < 10^-10
- [ ] Documentation complete with physical interpretation

### Phase 5: Complete Dynamics (2-3 days)

**üéØ Phase Goal:** Integrate full GENERIC dynamics with monitoring

9. **Extend `qig/dynamics.py`**:
   - [ ] Add `GenericDynamics` class or extend `InaccessibleGameDynamics`
     - Store H_eff and D[œÅ] alongside trajectory
     - Compute both at each integration step
     - Track entropy production rate
     - Monitor preservation of GENERIC structure
   - [ ] Add integration methods:
     - `integrate_generic(t_span, theta0)`: Full œÅÃá = -i[H_eff,œÅ] + D[œÅ]
     - `integrate_reversible(t_span, theta0)`: Unitary only
     - `integrate_irreversible(t_span, theta0)`: Dissipative only
   - [ ] Add diagnostics:
     - Track ||S|| and ||A|| over time
     - Monitor degeneracy condition violations
     - Compute cumulative entropy production

10. **Tests**:
    - [ ] `test_generic_dynamics.py`
      - Integrate full GENERIC dynamics for 2-qubit system
      - Compare reversible + irreversible vs full dynamics
      - Verify constraint preservation
      - Verify entropy monotonicity
      - Check energy conservation for reversible part
      - Check entropy production for irreversible part

**‚úÖ Phase 5 Completion Criteria (Gate to Phase 6):**
- [ ] All tests in `test_generic_dynamics.py` pass (~12 tests)
- [ ] Full GENERIC dynamics integrates successfully
- [ ] Reversible + irreversible = full dynamics: max error < 10^-6
- [ ] Constraint preservation: ||C(Œ∏(t)) - C(Œ∏_0)|| < 10^-6 throughout
- [ ] Entropy monotonicity: S(t+dt) - S(t) ‚â• -10^-12
- [ ] Energy conservation (reversible): |E(t) - E(0)| < 10^-8
- [ ] Cumulative entropy production computed correctly and non-negative
- [ ] Diagnostics track GENERIC structure preservation
- [ ] Documentation complete with integration examples

### Phase 6: GENERIC Decomposition Interface (2-3 days)

**üéØ Phase Goal:** High-level orchestration and user-friendly interface

11. **Create `qig/generic_decomposition.py`**:
    - [ ] Implement `GenericDecomposition` class:
      ```python
      class GenericDecomposition:
          def __init__(self, exp_fam: QuantumExponentialFamily):
              self.exp_fam = exp_fam
              self.results = {}
              
          def compute_all(self, theta: np.ndarray) -> dict:
              """Execute all 12 steps and return comprehensive results."""
              # Step 0: Initial state
              self.results['theta'] = theta
              self.results['rho'] = self.exp_fam.rho_from_theta(theta)
              
              # Steps 1-8: Information geometry
              self.results['psi'] = self.exp_fam.psi(theta)
              self.results['mu'] = self.exp_fam._grad_psi(theta)
              self.results['G'] = self.exp_fam.fisher_information(theta)
              self.results['marginal_entropies'] = self._marginal_entropies(theta)
              self.results['constraint_gradient'] = self._constraint_gradient(theta)
              self.results['nu'] = self._lagrange_multiplier(theta)
              self.results['grad_nu'] = self.exp_fam.lagrange_multiplier_gradient(theta)
              self.results['M'] = self.exp_fam.jacobian(theta)
              
              # Step 9: Decomposition
              self.results['S'] = self.exp_fam.symmetric_part(theta)
              self.results['A'] = self.exp_fam.antisymmetric_part(theta)
              
              # Step 10: Hamiltonian
              f_abc = compute_structure_constants(self.exp_fam.operators)
              eta = effective_hamiltonian_coefficients(
                  self.results['A'], theta, f_abc
              )
              self.results['eta'] = eta
              self.results['H_eff'] = effective_hamiltonian_operator(
                  eta, self.exp_fam.operators
              )
              
              # Step 11: Diffusion
              self.results['D'] = diffusion_operator(
                  self.results['S'], theta, self.exp_fam
              )
              
              # Step 12: Diagnostics
              self.results['diagnostics'] = self._compute_diagnostics()
              
              return self.results
              
          def _compute_diagnostics(self) -> dict:
              """Comprehensive validation checks."""
              # ... verification of all GENERIC properties
      ```
    - [ ] Implement `run_generic_decomposition(theta, exp_fam, **options)`
      - Convenience wrapper
      - Options for which steps to compute
      - Options for diagnostic level
    - [ ] Add pretty printing and visualization:
      - `print_summary()`: Human-readable results
      - `plot_decomposition()`: Visualize S and A
      - `plot_operators()`: Visualize H_eff and D[œÅ]

12. **Documentation and examples**:
    - [ ] Create `examples/generic_decomposition_qutrit.py`:
      - Reproduce exact calculation from LaTeX document
      - 2-qutrit system (16 parameters)
      - Start near LME origin
      - Print all 12 steps with intermediate results
      - Verify against expected structure
    - [ ] Create `examples/generic_decomposition_qubit_pair.py`:
      - Simpler case: 2-qubit entangled pair (15 parameters with pair basis)
      - Show complete GENERIC decomposition
      - Integrate dynamics and plot trajectories
    - [ ] Update documentation:
      - Add GENERIC decomposition section to user guide
      - Document GENERIC decomposition API
      - Add theory section on Lie-algebraic structure

**‚úÖ Phase 6 Completion Criteria (Gate to Phase 7):**
- [ ] `GenericDecomposition` class fully implemented
- [ ] All 12 steps execute successfully in `compute_all()`
- [ ] Convenience function `run_generic_decomposition()` works
- [ ] Example script `generic_decomposition_qutrit.py` reproduces LaTeX calculations
- [ ] Example script `generic_decomposition_qubit_pair.py` runs successfully
- [ ] Visualization functions produce clear plots
- [ ] `_compute_diagnostics()` returns comprehensive validation report
- [ ] All intermediate results stored and accessible
- [ ] User guide section complete with examples
- [ ] API documentation complete

### Phase 7: Testing and Validation (2-3 days)

**üéØ Phase Goal:** Comprehensive integration testing and validation against paper

13. **Comprehensive test suite**:
    - [ ] `test_generic_decomposition_integration.py`:
      - End-to-end test for 2-qubit system
      - End-to-end test for 2-qutrit system
      - Verify all GENERIC properties
      - Regression tests against known results
    - [ ] Numerical precision tests:
      - Test near pure-state boundary (small Œµ)
      - Test different regularization levels
      - Document numerical stability limits
    - [ ] Property-based tests:
      - GENERIC structure preserved throughout integration
      - Entropy monotonicity
      - Constraint preservation

14. **Validation against paper**:
    - [ ] Verify qutrit optimality analysis uses correct GENERIC decomposition
    - [ ] Check that entropy gradient factor R matches theoretical prediction
    - [ ] Validate that single-pair analysis extends to multi-pair (Appendix structure)

**‚úÖ Phase 7 Completion Criteria (Gate to Phase 8):**
- [ ] All tests in `test_generic_decomposition_integration.py` pass (~20 tests)
- [ ] End-to-end test for 2-qubit system passes
- [ ] End-to-end test for 2-qutrit system passes
- [ ] All GENERIC properties verified throughout full computation
- [ ] Regression tests against reference data pass
- [ ] LaTeX document calculations successfully reproduced
- [ ] Werner state analytical solution matches numerical: error < 10^-6
- [ ] Paper claims validated (LME origin, qutrit optimality, entropy gradient factor R)
- [ ] Known issues documented with explanations
- [ ] Performance profiled and documented

### Phase 8: Documentation and Cleanup (1-2 days)

**üéØ Phase Goal:** Polish documentation and prepare for release

15. **Documentation**:
    - [ ] Docstrings for all new functions and classes
    - [ ] Mathematical descriptions in LaTeX
    - [ ] Usage examples in docstrings
    - [ ] Theory section in Sphinx docs explaining GENERIC decomposition

16. **Code review and polish**:
    - [ ] Code review of all new modules
    - [ ] Performance profiling and optimization
    - [ ] Clean up any debugging code
    - [ ] Ensure consistent British English spelling

**‚úÖ Phase 8 Completion Criteria (Final Gate - CIP Complete):**
- [ ] All docstrings complete with LaTeX math and examples
- [ ] Theory section added to Sphinx docs
- [ ] User guide section for GENERIC decomposition complete
- [ ] API reference updated
- [ ] All code reviewed and polished
- [ ] Performance profiling complete
- [ ] No debugging code remains
- [ ] Consistent British English throughout
- [ ] CHANGELOG updated
- [ ] Final integration test suite passes (all 73+ tests)
- [ ] Documentation builds without warnings
- [ ] Example notebooks run end-to-end

**üéâ CIP-0006 Status: COMPLETED** (when all Phase 8 criteria met)

## Backward Compatibility

This CIP is purely additive and maintains full backward compatibility:

- **No changes** to existing API of `QuantumExponentialFamily`, `InaccessibleGameDynamics`
- **New modules** (`structure_constants`, `generic`, `generic_decomposition`) are independent
- **New methods** added to existing classes are optional
- **Existing tests** continue to pass
- **Existing examples and scripts** continue to work

Users can adopt the GENERIC decomposition functionality incrementally without modifying existing code.

## Testing Strategy

### Validation Principles

Given the complexity of the analytic procedures, we adopt a **multi-method cross-validation** approach:

1. **Compare multiple computational methods** for the same quantity
2. **Check mathematical properties** (symmetries, identities, bounds)
3. **Verify against known analytical solutions** for simple cases
4. **Use numerical differentiation** as independent validation
5. **Monitor physical constraints** throughout

### Cross-Validation Tests

For each major computational step, implement multiple independent methods:

#### 1. Structure Constants Validation

**Method A: Direct commutator**
```python
# [F_a, F_b] = 2i Œ£_c f_abc F_c
commutator = F_a @ F_b - F_b @ F_a
```

**Method B: Decompose in basis**
```python
# Project commutator onto each basis element
f_abc = Tr(commutator @ F_c) / Tr(F_c @ F_c)
```

**Validation checks:**
- [ ] Jacobi identity: Œ£_c (f_abc f_cde + cyclic permutations) ‚âà 0
- [ ] Antisymmetry: f_abc = -f_bac
- [ ] Compare with known values for su(2) and su(3)
- [ ] Commutators on different sites: f_abc = 0 when operators don't overlap

#### 2. Symmetric/Antisymmetric Decomposition

**Method A: Direct formula**
```python
S = 0.5 * (M + M.T)
A = 0.5 * (M - M.T)
```

**Validation checks:**
- [ ] S == S.T (symmetric) with tolerance ~10^-14
- [ ] A == -A.T (antisymmetric) with tolerance ~10^-14
- [ ] M == S + A (reconstruction) with tolerance ~10^-14
- [ ] ||Sa|| < tol (degeneracy: S annihilates constraint gradient)
- [ ] ||A(-GŒ∏)|| < tol (degeneracy: A annihilates entropy gradient)

**Physical checks:**
- [ ] Entropy production: Œ∏^T S Œ∏ ‚â• 0 (S positive semidefinite on tangent space)
- [ ] Energy conservation: Tr(A) ‚âà 0 (volume preservation)

#### 3. Effective Hamiltonian Extraction

**Method A: Solve linear system**
```python
# A_ab Œ∏_b = Œ£_c f_abc Œ∑_c
# Construct F_rc = Œ£_b f_rbc Œ∏_b
# Solve F @ Œ∑ = A @ Œ∏
eta = np.linalg.solve(F, A @ theta)
```

**Method B: Direct commutator fitting**
```python
# Minimize ||i[H_eff, œÅ] - œÅ_dot_reversible||
# where œÅ_dot_reversible comes from A
eta_fit = least_squares_fit(...)
```

**Method C: Eigenvalue evolution (for small systems)**
```python
# Track eigenvalue phases under unitary evolution
# H_eff eigenvectors should match œÅ eigenvectors
```

**Validation checks:**
- [ ] H_eff == H_eff^‚Ä† (Hermiticity) with tolerance ~10^-12
- [ ] Tr(H_eff) ‚âà 0 (traceless for Lie algebra)
- [ ] Compare -i[H_eff, œÅ] with A-generated flow: error < 10^-8
- [ ] Energy conservation: d/dt Tr(H_eff œÅ) ‚âà 0 for unitary part
- [ ] Compare Method A and Method B: ||Œ∑_A - Œ∑_B|| < 10^-6

**Known solutions for validation:**
- [ ] **Two-qubit Werner state**: Known H_eff = Œ£_i J_i œÉ_i^(1) ‚äó œÉ_i^(2)
- [ ] **Isotropic state**: Symmetric H_eff under qubit exchange
- [ ] **Product state**: H_eff should be sum of local Hamiltonians

#### 4. Diffusion Operator

**Method A: Kubo-Mori flow**
```python
# D[œÅ] = Œ£_a (S @ q)_a * ‚àÇ_a œÅ
# where ‚àÇ_a œÅ is Kubo-Mori derivative
D_rho = sum((S @ q)[a] * duhamel_derivative(theta, a) 
            for a in range(n_params))
```

**Method B: Milburn approximation (near equilibrium)**
```python
# D[œÅ] ‚âà -Œ≥/2 [H_eff, [H_eff, œÅ]]
D_rho_milburn = -gamma/2 * double_commutator(H_eff, rho)
```

**Method C: Lindblad form (if applicable)**
```python
# D[œÅ] = Œ£_k Œ≥_k (L_k œÅ L_k^‚Ä† - 1/2{L_k^‚Ä† L_k, œÅ})
# Extract jump operators L_k from S
```

**Validation checks:**
- [ ] D[œÅ] == D[œÅ]^‚Ä† (Hermiticity) with tolerance ~10^-10
- [ ] Tr(D[œÅ]) ‚âà 0 (trace preservation) with tolerance ~10^-12
- [ ] Entropy production: -Tr(œÅ log œÅ D[œÅ]) ‚â• -10^-14 (non-negative, allowing small numerical error)
- [ ] Compare Methods A and B near equilibrium: relative error < 10^-4
- [ ] Positivity preservation: eigenvalues of œÅ + Œµ D[œÅ] all ‚â• 0 for small Œµ

**Physical checks:**
- [ ] Approach to equilibrium: D[œÅ_eq] ‚âà 0 at stationary state
- [ ] Detailed balance (if applicable): œÅ_eq D[œÅ] œÅ_eq^{-1} = -D[œÅ]

#### 5. Full Jacobian Validation

**Method A: Analytic formula (already implemented)**
```python
M = -G - nabla_G_theta + nu * nabla2_C + outer(a, grad_nu)
```

**Method B: Finite differences**
```python
M_fd[i,j] = (flow(theta + eps*e_j)[i] - flow(theta)[i]) / eps
```

**Method C: Automatic differentiation**
```python
M_autodiff = jacobian(lambda th: flow_vector(th), theta)
```

**Validation checks:**
- [ ] Compare analytic vs finite differences: max error < 10^-5
- [ ] Compare analytic vs autodiff: max error < 10^-8
- [ ] Constraint tangency: M @ a ‚âà 0 (flow stays on manifold)
- [ ] Entropy monotonicity: Œ∏^T M Œ∏ ‚â§ 10^-12 (allowing small numerical error)

### Unit Tests

Each new module will have comprehensive unit tests:

1. **`test_structure_constants.py`** (~10 tests):
   - Verify su(2) structure constants
   - Verify su(3) structure constants
   - Test Jacobi identity for various dimensions
   - Test tensor product structure
   - Test caching and performance

2. **`test_generic_decomposition.py`** (~8 tests):
   - Test S = S^T and A = -A^T
   - Test M = S + A reconstruction
   - Test degeneracy conditions near origin
   - Test degeneracy conditions away from origin

3. **`test_generic_hamiltonian.py`** (~15 tests):
   - Test coefficient extraction for su(2)
   - Test coefficient extraction for su(3)
   - Verify H_eff Hermiticity
   - Verify commutator evolution matches A
   - Test near-singular cases
   - **Cross-validation**: Compare linear solver vs least-squares fitting
   - **Known solutions**: Werner state, isotropic state, product state
   - **Symmetry checks**: Verify permutation symmetry when applicable
   - Energy conservation under unitary evolution
   - Tracelessness of H_eff

4. **`test_diffusion_operator.py`** (~12 tests):
   - Test Kubo-Mori derivative computation
   - Verify D[œÅ] Hermiticity
   - Verify trace preservation
   - Verify entropy production ‚â• 0
   - **Cross-validation**: Compare Kubo-Mori vs Milburn near equilibrium
   - **Cross-validation**: Compare with Lindblad form when applicable
   - Positivity preservation check
   - Approach to equilibrium: D[œÅ_eq] ‚âà 0
   - Test different distance from equilibrium
   - Detailed balance verification (when applicable)

5. **`test_generic_dynamics.py`** (~12 tests):
   - Test full GENERIC integration
   - Test reversible vs irreversible separation
   - Verify constraint preservation
   - Verify entropy monotonicity
   - Test different time parametrizations

6. **`test_generic_decomposition_integration.py`** (~20 tests):
   - End-to-end for 2 qubits
   - End-to-end for 2 qutrits
   - Verify all 12 steps produce valid results
   - Regression against known numerical values
   - Test different initial states
   - **Cross-validation**: Compare reversible + irreversible vs full dynamics
   - **Consistency**: Verify all intermediate quantities satisfy mathematical properties
   - **Physical constraints**: Check throughout entire procedure
   - Test at different points on constraint manifold
   - Numerical stability tests near pure-state boundary

**Total: ~73 new tests**, all with clear tolerances documented.

### Regression Test Suite

Create a reference database of known-good results:

```python
# tests/reference_data/
‚îú‚îÄ‚îÄ su2_structure_constants.npy       # Known SU(2) structure constants
‚îú‚îÄ‚îÄ su3_structure_constants.npy       # Known SU(3) structure constants
‚îú‚îÄ‚îÄ two_qubit_generic_decomp.pkl      # Complete decomposition for 2 qubits
‚îú‚îÄ‚îÄ two_qutrit_generic_decomp.pkl     # Complete decomposition for 2 qutrits
‚îî‚îÄ‚îÄ werner_state_hamiltonian.npy      # Analytical H_eff for Werner state
```

**Regression tests:**
- [ ] Load reference data
- [ ] Run computation with same parameters
- [ ] Compare all intermediate results
- [ ] Flag if any quantity differs by > tolerance
- [ ] Document expected changes when improving precision

### Integration Tests

1. **Reproduce LaTeX document calculations**:
   - Run `examples/generic_decomposition_qutrit.py`
   - Verify all intermediate results match theoretical expectations
   - Check numerical values against hand calculations
   - **Cross-validate**: Run same calculation with multiple methods
   - Document all tolerance thresholds used

2. **Known analytical solutions**:
   - **Two-qubit Werner state**: œÅ = p|œà‚ü©‚ü®œà| + (1-p)I/4
     - Compute H_eff analytically
     - Compare with numerical extraction: error < 10^-6
   - **Harmonic oscillator (if applicable)**:
     - Known H_eff = œâ(a^‚Ä†a + 1/2)
     - Verify GENERIC structure matches theory
   - **Product states**:
     - H_eff should be sum of local Hamiltonians
     - Cross-pair coupling should be zero

3. **Validation against paper claims**:
   - Verify GENERIC decomposition at LME origin
   - Check qutrit optimality through GENERIC decomposition
   - Validate entropy gradient factor R
   - **Cross-validate** with finite differences where possible

### Numerical Precision

**Tolerance hierarchy** (from most to least strict):

| Quantity | Expected Tolerance | Validation Method |
|----------|-------------------|-------------------|
| Symmetry (S = S^T, A = -A^T) | ~10^-14 | Machine precision |
| Hermiticity (H_eff = H_eff^‚Ä†) | ~10^-12 | Direct computation |
| Trace preservation (Tr(D[œÅ])) | ~10^-12 | Direct computation |
| Structure constants (vs known) | ~10^-10 | Compare to references |
| Jacobi identity | ~10^-8 | Triple sum of structure constants |
| Analytic vs autodiff Jacobian | ~10^-8 | Cross-validation |
| Degeneracy conditions (Sa, A‚àáH) | ~10^-6 | Numerical derivatives in constraint |
| Commutator matching (-i[H,œÅ] vs A-flow) | ~10^-6 | Kubo-Mori transformation |
| Analytic vs finite-diff Jacobian | ~10^-5 | Finite difference accuracy |
| Milburn vs Kubo-Mori (near eq.) | ~10^-4 | Different approximations |

**Regularization tests:**
- Test with Œµ = 10^-3, 10^-4, 10^-5, 10^-6, 10^-7, 10^-8
- Document which quantities become unstable at each level
- Provide recommended Œµ for typical use cases
- Profile numerical stability near pure-state boundary
- Provide guidance on precision vs. performance tradeoffs

**Adaptive tolerance:**
- Implement `check_consistency()` function that adjusts tolerances based on system state
- Near pure states: relax tolerances for near-zero eigenvalues
- Far from origin: use stricter tolerances

### Performance

- Profile computation time for typical cases (n=2, d=2,3)
- Identify bottlenecks (likely: structure constants, Jacobian)
- Document scaling with system size
- Optimize critical paths if needed

## Related Requirements

This CIP addresses several core requirements from the quantum inaccessible game project:

### From LaTeX Document (`handle-turning-example.tex`)

- **Complete computational procedure**: Implements systematic 12-step decomposition explicitly
- **Lie-algebraic structure**: Uses Gell-Mann generators and structure constants
- **GENERIC decomposition**: Separates reversible and irreversible dynamics
- **Single-pair analysis**: Supports both single pair and multi-pair systems

### From Project Goals

- **Numerical validation**: Provides tools to validate theoretical predictions
- **Qutrit optimality**: Enables computation of entropy gradient factor R
- **Reproducibility**: Makes paper calculations explicit and runnable
- **Extensibility**: Framework for exploring different dimensions and constraints

### Related to Existing CIPs

- **CIP-0001**: Builds on refactored module structure
- **CIP-0002**: May utilize advanced analysis tools
- **CIP-0003**: Complements dynamics infrastructure
- **CIP-0004**: Follows test tolerance framework
- **CIP-0005**: Will be documented in Sphinx

## Implementation Status

### Phase 0: Validation Infrastructure ‚úÖ **COMPLETED** (2025-12-01)
- [x] Create `qig/validation.py` with comparison utilities
- [x] Implement `ValidationReport` class
- [x] Generate and save reference data for SU(2) and SU(3)
- [x] Document all reference sources
- [x] 32 comprehensive tests (all passing in 0.49s)
- [x] Documentation integrated into Sphinx (`docs/source/development/validation_framework.rst`)
- **Commit:** `a610997` (+1,282 lines)
- **Gate to Phase 1:** OPEN ‚úì

### Phase 1: Lie Algebra Structure ‚úÖ **COMPLETED** (2025-12-01)
- [x] Create `qig/structure_constants.py`
- [x] Implement structure constant computation
- [x] Implement Jacobi identity verification
- [x] Create cache for common cases
- [x] Write tests (`test_structure_constants.py`) (21 tests, all passing in 0.38s)
- [x] API documentation with examples
- **Commit:** `21d6b61` (+862 lines)
- **Gate to Phase 2:** OPEN ‚úì

### Phase 2: GENERIC Decomposition ‚úÖ **COMPLETED** (2025-12-01)
- [x] Add `symmetric_part()` to `QuantumExponentialFamily`
- [x] Add `antisymmetric_part()` to `QuantumExponentialFamily`
- [x] Add `verify_degeneracy_conditions()` to `QuantumExponentialFamily`
- [x] Create `examples/generic_decomposition.py` (now generic_decomposition_demo.py)
- [x] 12 comprehensive tests (all passing in 7.22s)
- **Commit:** `f1dcb6b` (+540 lines)
- **Gate to Phase 3:** OPEN ‚úì

### Phase 3: Effective Hamiltonian ‚úÖ **COMPLETED** (2025-12-01)
- [x] Create `qig/generic.py`
- [x] Implement `effective_hamiltonian_coefficients()` (Method A: linear solver)
- [x] Implement `effective_hamiltonian_coefficients_lstsq()` (Method B: least-squares)
- [x] Implement `effective_hamiltonian_operator()`
- [x] Implement `verify_hamiltonian_evolution()`
- [x] Implement `cross_validate_hamiltonian_coefficients()`
- [x] Write tests (`test_generic_hamiltonian.py`) (15 tests, all passing in 1.88s)
- **Commit:** `27fe40e` (+645 lines)
- **Gate to Phase 4:** OPEN ‚úì

### Phase 4: Diffusion Operator ‚úÖ **COMPLETED** (2025-12-01)
- [x] Implement `kubo_mori_derivatives()`
- [x] Implement `diffusion_operator()`
- [x] Implement `milburn_approximation()`
- [x] Implement `verify_diffusion_operator()`
- [x] Implement `compare_diffusion_methods()`
- [x] Write tests (`test_diffusion_operator.py`) (16 tests, all passing in 4.09s)
- **Commit:** `a3fc78c` (+572 lines)
- **Gate to Phase 5:** OPEN ‚úì

### Phase 5: Complete Dynamics ‚úÖ **COMPLETED** (2025-12-01)
- [x] Extend `qig/dynamics.py` with GENERIC support
- [x] Add `GenericDynamics` class
  - [x] `compute_generic_decomposition()` - Full GENERIC analysis at any Œ∏
  - [x] `integrate_reversible()` - Hamiltonian-only dynamics
  - [x] `integrate_irreversible()` - Dissipative-only dynamics
  - [x] `integrate_with_monitoring()` - Full dynamics with structure tracking
- [x] Track H_eff, D[œÅ], entropy production, S/A norms along trajectories
- [x] Optional diffusion operator computation (expensive)
- [x] Write tests (`test_generic_dynamics.py`) (16 tests, all passing in 163s)
- **Commit:** `8967f9a` (+586 lines)
- **Gate to Phase 6:** OPEN ‚úì

### Phase 6: GENERIC Decomposition Interface
- [ ] Create `qig/generic_decomposition.py`
- [ ] Implement `GenericDecomposition` class
- [ ] Implement `run_generic_decomposition()`
- [ ] Create `examples/generic_decomposition_qutrit.py`
- [ ] Create `examples/generic_decomposition_qubit_pair.py`

### Phase 7: Testing and Validation
- [ ] Write comprehensive test suite (~63 tests)
- [ ] Validate against LaTeX document
- [ ] Validate against paper claims
- [ ] Document numerical precision and tolerances

### Phase 8: Documentation
- [ ] Write docstrings for all new code
- [ ] Add theory section to Sphinx docs
- [ ] Add user guide section for GENERIC decomposition
- [ ] Update API reference

## References

### Code
- **Existing infrastructure**:
  - `qig/exponential_family.py`: Foundation for information geometry
  - `qig/pair_operators.py`: Gell-Mann generators already implemented
  - `qig/duhamel.py`: High-precision Kubo-Mori derivatives
  - `qig/dynamics.py`: Integration framework

### Documentation
- **LaTeX source**: `/Users/neil/lawrennd/the-inaccessible-game-orgin/handle-turning-example.tex`
  - Section 2: Gell-Mann generators for su(3)
  - Section 3: Complete 12-step procedure
  - Section 4: Connection to LME origin
  - Section 5: Symmetric configuration simplifications
- **Main paper**: *The Origin of the Inaccessible Game*
  - GENERIC structure theory
  - Entropy gradient factor R
  - Qutrit optimality argument

### Theory
- **GENERIC framework**: Grmela & √ñttinger formalism
- **Lie-algebraic methods**: Structure constants and commutation relations
- **Quantum information geometry**: BKM metric, Kubo-Mori derivatives
- **Constrained dynamics**: Lagrange multipliers and projection

## Notes

### Computational Complexity

Expected computational costs for GENERIC decomposition procedure:

| System | Parameters | F_a dim | Structure constants | Jacobian | H_eff extraction |
|--------|-----------|---------|---------------------|----------|------------------|
| 2 qubits (local) | 6 | 4√ó4 | ~20 | Fast | Fast |
| 2 qubits (pair) | 15 | 4√ó4 | ~3,000 | Medium | Fast |
| 2 qutrits (local) | 16 | 9√ó9 | ~1,200 | Medium | Medium |
| 2 qutrits (pair) | 80 | 9√ó9 | ~500,000 | Slow | Medium |

**Bottlenecks**: Structure constant computation and Jacobian evaluation. 
**Optimization opportunities**: Cache structure constants, use sparse storage.

### Future Extensions

Potential future work building on this CIP:

1. **Analytic Jacobi identity**: Symbolic verification for special cases
2. **Efficient structure constant storage**: Sparse representation for large systems
3. **Parallel computation**: Distribute structure constant computation
4. **Adaptive precision**: Automatically adjust tolerances based on state
5. **Interactive visualization**: Real-time plotting of H_eff and D[œÅ] evolution
6. **Comparison tools**: Compare GENERIC decomposition across different states

### Connection to Paper

This CIP implements the computational foundation for several paper claims:

- **Lemma 4.1**: Verified via constraint gradient at origin
- **Lemma 6.1**: Qutrit optimality via entropy gradient factor R computation
- **GENERIC decomposition**: Explicit separation validated numerically
- **Appendix structure**: Single-pair to multi-pair extensivity

Having working code strengthens all these theoretical results.

