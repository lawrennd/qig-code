---
title: "Quantum Thermalization via Maximum Entropy Production Principle (MEPP) and Coarse Graining"
date: 2025-07-24
status: "proposed"
priority: "High"
author: "Neil"
---

# CIP-0005: Quantum Thermalization via Maximum Entropy Production Principle (MEPP) and Coarse Graining

## Status
- [x] Proposed ‚Üí Initial implementation complete
- [x] Accepted ‚Üí Working simulation with coarse graining
- [x] Implemented ‚Üí Core simulation working, SEA needs improvement
- [ ] Closed ‚Üí Ready for review

## Description

This CIP documents the implementation of a quantum thermalization simulation using Maximum Entropy Production Principle (MEPP) evolution with random phase-string gates and Steepest-Entropy-Ascent (SEA) dynamics. The key insight is that entropy increase comes from *coarse graining effects* rather than starting with mixed states. The idea is to show that this provides a mechanism for stage 1 pure dephasing of the initial pure quantum system enabling stage 2 isolation process to follow.

## Motivation

Understanding quantum thermalization requires:
1. *Proper entropy dynamics*: How does entropy emerge from pure quantum evolution?
2. *Coarse graining effects*: How does tracing out part of a system create effective entropy?
3. *SEA validation*: Does Steepest-Entropy-Ascent capture the coarse-grained behavior?

The simulation demonstrates that random quantum gates on a pure state create correlations that become visible as entropy when we coarse grain by partial tracing.

## Implementation

### Core Components

1. *MEPP Evolution*: Random phase-string gates that drive maximum entropy production
2. *Coarse Graining*: Partial trace over subsystem to create effective mixed states
3. *SEA Evolution*: Steepest-Entropy-Ascent dynamics for comparison
4. *Entropy Tracking*: Von Neumann entropy of coarse-grained states

### Physics Implementation

- *Initial State*: Pure state (zero entropy)
- *Evolution*: Random unitary gates preserve purity
- *Coarse Graining*: Partial trace reveals effective entropy
- *Result*: Entropy fluctuations show quantum correlations

## Implementation Status

### Completed ‚úÖ
- [x] Random phase-string gate generation (Pauli-X, Y, Z for qubits/qutrits)
- [x] Proper partial trace implementation for coarse graining
- [x] Von Neumann entropy calculation with numerical stability
- [x] Pure state initialization and unitary evolution
- [x] Entropy tracking during evolution
- [x] Qubit and qutrit system support
- [x] *Maximally entangled Bell pairs initialization* (qubits and qutrits)
- [x] *Proper dephasing channel implementation* based on theory equation (1)
- [x] *Gradual dephasing with cumulative time evolution* (Œ≥_œÑ = Œ≥_per_block * œÑ)
- [x] *Two-stage thermalization process*: Stage A (dephasing) + Stage B (isolation)
- [x] *Optimized time allocation*: 10 steps dephasing, 20 steps isolation for qubits
- [x] *Theory-compliant entropy growth*: 0.000 ‚Üí 0.588 ‚Üí 0.689 ‚Üí 0.693 (saturation)

### In Progress üîÑ
- [ ] *Implement proper SEA dynamics*: ‚àÇœÑœÅ = i[log œÅ*, œÅ] with œÅ* = argmax S(œÅÃÉ) subject to fixed marginals
- [ ] *Validate SEA predictions* against exact quantum evolution
- [ ] *Test with larger systems for more robust entropy increase*
- [ ] *Investigate qutrit system instability during isolation phase*

### Planned üìã
- [ ] Add mutual information calculations
- [ ] Implement different coarse graining strategies
- [ ] Add entanglement entropy tracking
- [ ] Create visualization of entropy dynamics
- [ ] *Scale to larger systems (8+ qubits) for better thermalization*
- [ ] *Optimize isolation phase parameters for stable evolution*

### Advanced Theoretical Extensions üî¨ (Jaynes/Natural-Parameter Framework)
- [ ] *0: Hard constraint projector* - Store P_hard that separates exact vs relaxing constraints
- [ ] *A-1: Natural parameters* - Compute canonical parameters Œ∏_j = log p_j - œà in soft coordinates
- [ ] *A-2: SEA verification* - Track Œ∏Ãá_soft and verify Œ∏Ãá = -G_‚à•Œ∏ numerically
- [ ] *B: Fisher as effective masses* - Eigenvalues Œª_k as curvature of entropy vs constraint
- [ ] *C: Automatic charge identification* - Classify hard (Œª=0) and soft (Œª<Œª_cut) charges
- [ ] *D: Normal-mode particles* - Particle excitations as oscillations of natural parameters
- [ ] *E: Spatial embedding* - Auto-bin basis strings to L√óL grid for field Œ∏(x) visualization
- [ ] *F: Spectrum flow plots* - Time √ó log Œª_k heatmaps showing quasi-symmetry plateaus

## Key Insights

1. *Coarse Graining Entropy*: The entropy increase comes from tracing out part of the system, not from starting with mixed states
2. *Pure State Evolution*: Unitary gates preserve purity; entropy emerges from effective description
3. *Numerical Stability*: Proper eigenvalue handling prevents negative entropy values
4. *System Size Effects*: Larger systems show more robust entropy dynamics
5. *Bell Pairs Initialization*: Maximally entangled states provide the right coherences for dephasing
6. *Gradual Dephasing*: Cumulative time evolution (Œ≥_œÑ = Œ≥_per_block * œÑ) captures proper dephasing dynamics
7. *Two-Stage Process*: Stage A (dephasing) completes quickly (~4-5 steps), Stage B (isolation) needs careful time allocation
8. *Time Optimization*: 90 steps of isolation caused excessive fluctuations; 20 steps shows cleaner evolution

## Technical Details

### Coarse Graining Implementation
```python
# Trace over first subsystem_size qubits
subsystem_dim = self.d ** subsystem_size
remaining_dim = self.d ** (self.n_qubits - subsystem_size)
rho_tensor = rho.reshape(subsystem_dim, remaining_dim, subsystem_dim, remaining_dim)
rho_reduced = np.zeros((remaining_dim, remaining_dim), dtype=complex)
for i in range(subsystem_dim):
    rho_reduced += rho_tensor[i, :, i, :]
```

### Dephasing Channel Implementation
```python
# Theory equation (1): œÅÃÑ(œÑ) = (1-e^(-Œ≥œÑ))[diag(|a|¬≤)] + e^(-Œ≥œÑ)|Œ®‚ÇÄ‚ü©‚ü®Œ®‚ÇÄ|
gamma_per_block = 0.1 * sigma_alpha**2  # Gradual dephasing rate
tau = step_number * block_size
gamma_tau = gamma_per_block * tau
dephasing_factor = 1 - np.exp(-gamma_tau)
dephased_rho = dephasing_factor * np.diag(populations) + (1 - dephasing_factor) * rho
```

### Bell Pairs Initialization
```python
# Create product of Bell pairs |Œ¶‚Å∫‚ü© = (|00‚ü© + |11‚ü©)/‚àö2
for i in range(0, self.n_qubits, 2):
    state = self._apply_hadamard(state, i)  # Create superposition
    state = self._apply_cnot(state, i, i+1)  # Create entanglement
```

### MEPP Gate Generation
```python
# Random Pauli strings with phase factors for maximum entropy production
pauli_types = ['x', 'y', 'z']  # Non-diagonal operations
gate = expm(1j * alpha * pauli_string)
```

### SEA Dynamics Implementation (TODO)
```python
# Steepest-Entropy-Ascent: ‚àÇœÑœÅ = i[log œÅ*, œÅ]
# where œÅ* = argmax S(œÅÃÉ) subject to fixed marginals œÅ·µ¢‚ÅΩ¬π‚Åæ
def sea_evolution_step(self, rho, dt=0.01):
    # 1. Find œÅ* that maximizes S(œÅÃÉ) with fixed marginals
    # 2. Compute commutator [log œÅ*, œÅ]
    # 3. Evolve: œÅ(œÑ + dœÑ) = œÅ(œÑ) + i dœÑ [log œÅ*, œÅ]
    # Current implementation is placeholder
    return rho + dt * np.random.randn(*rho.shape) * 0.1
```

### Jaynes/Natural-Parameter Framework Implementation

#### Hard Constraint Projector
```python
def _projector_on_correlations(self):
    """Build matrix that projects away single-site populations (hard constraints)."""
    D = self.d**self.n_qubits
    P = np.eye(D-1)         # start in prob-simplex basis (skip trace)
    hard_rows = []
    for i in range(self.n_qubits):
        for a in range(self.d-1):   # only d-1 independent probs/site
            hard_rows.append(self._index_of_basis_proj(i, a))
    keep = [j for j in range(D-1) if j not in hard_rows]
    return P[keep, :]       # shape (D-1-2N, D-1)

# Store projector for reuse
self.P_soft = self._projector_on_correlations()
```

#### Natural Parameters (Canonical Coordinates)
```python
def natural_params(self, rho):
    """Compute canonical parameters Œ∏_j = log p_j - œà in soft coordinates."""
    p = np.diag(rho).real
    p = p / p.sum()
    theta_full = np.log(p) - np.log(p).mean()         # subtract œà
    theta_soft = self.P_soft @ theta_full             # drop hard components
    return theta_soft
```

#### SEA Verification in Natural Parameters
```python
def verify_sea_dynamics(self, rho_gates, rho_after_block, dt_block):
    """Verify Œ∏Ãá = -G_‚à•Œ∏ numerically."""
    theta_now  = self.natural_params(rho_gates)
    theta_next = self.natural_params(rho_after_block)
    dtheta     = (theta_next - theta_now) / dt_block
    rhs        = -self.fisher_block(rho_gates) @ theta_now
    sea_error  = np.linalg.norm(dtheta - rhs)
    self.sea_error_history.append(sea_error)
    return sea_error
```

#### Automatic Charge Classification
```python
def classify_charges(self, fisher_eigenvalues, lambda_cut=1e-6):
    """Classify hard (Œª=0) and soft (Œª<Œª_cut) charges automatically."""
    hard_charges = np.where(fisher_eigenvalues < 1e-12)[0]  # Exactly conserved
    soft_charges = np.where((fisher_eigenvalues >= 1e-12) & 
                           (fisher_eigenvalues < lambda_cut))[0]  # Quasi-conserved
    
    charge_info = {
        'hard_charges': hard_charges.tolist(),
        'soft_charges': soft_charges.tolist(),
        'hard_count': len(hard_charges),
        'soft_count': len(soft_charges),
        'lambda_cut': lambda_cut
    }
    return charge_info
```

#### Normal Mode Particles
```python
def create_particle_excitation(self, rho, eigen_vector, epsilon=1e-6):
    """Create particle excitation as oscillation of natural parameter."""
    p = np.diag(rho).real
    p = p / p.sum()
    
    # Perturb: p_j ‚Üí p_j * exp(Œµ * e_min,j)
    p_perturbed = p * np.exp(epsilon * eigen_vector)
    p_perturbed = p_perturbed / p_perturbed.sum()  # Renormalize
    
    # Convert back to density matrix
    rho_perturbed = np.diag(p_perturbed)
    return rho_perturbed

def track_particle_decay(self, initial_rho, eigen_vector, n_steps=50):
    """Track standing-wave decay e^(-Œªt) of particle mode."""
    current_rho = self.create_particle_excitation(initial_rho, eigen_vector)
    decay_history = []
    
    for step in range(n_steps):
        # Extract natural parameter amplitude
        theta = self.natural_params(current_rho)
        amplitude = np.dot(theta, eigen_vector)  # Project onto mode
        decay_history.append(amplitude)
        
        # Evolve one step
        current_rho = self._evolve_one_step(current_rho)
    
    return decay_history
```

## References

- *Jaynes MaxEnt Principle*: Canonical parameters as Lagrange multipliers
- *Fisher Information Geometry*: Natural coordinates for probability manifolds  
- *Steepest-Entropy-Ascent*: SEA dynamics in natural parameter space
- *MEPP Implementation*: `mepp.py` with Jaynes/natural-parameter framework
- *Related CIPs*: CIP-0005 (MEPP thermalization with SEA dynamics)

## Related Requirements
This CIP addresses the following requirements using the Jaynes/natural-parameter framework:

1. *Consistent MaxEnt Foundation*: All constraints and dynamics expressed in canonical coordinates
2. *Charge Identification*: Automatic classification of conserved vs quasi-conserved quantities
3. *Particle Interpretation*: Normal modes as oscillations of natural parameters with effective masses Œª_k
4. *Spatial Field Theory*: Natural parameters Œ∏(x) as observable fields with Gauss law divergence

*Author*: Neil  
*Date*: 2025-07-25  

## Related CIPs

- [CIP-0006](./cip0006.md): AISTATS Paper Draft Restructuring - paper context for this simulation
- [CIP-0007](./cip0007.md): Stage 3 Plateau/Stalling Regime - extends this simulation to cover full dynamics

## Related Tasks

- *Backlog*: `2025-07-25_jaynes-natural-parameters.md` - Natural parameter framework implementation
- *Backlog*: `2025-07-25_charge-classification.md` - Automatic hard/soft charge identification  
- *Backlog*: `2025-07-25_sea-verification.md` - SEA dynamics verification in natural coordinates
- *Backlog*: `2025-07-25_spectrum-flow-analysis.md` - Time √ó log Œª_k heatmaps for quasi-symmetry plateaus