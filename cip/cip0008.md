---
author: "Neil Lawrence"
created: "2025-12-06"
id: "0008"
last_updated: "2025-12-07"
status: implemented
tags:
- cip
- multi-pair
- regularisation
- efficiency
- product-states
title: "Efficient Multi-Pair Origin Machinery with Whole-System Regularisation"
---

# CIP-0008: Efficient Multi-Pair Origin Machinery with Whole-System Regularisation

## Summary

Extend the quantum exponential family machinery to efficiently handle multi-pair product states at the inaccessible game origin, with:
1. **Whole-system regularisation** with configurable regularisation matrix σ
2. **Exploitation of tensor product structure** when σ permits
3. **Support for the "many paths from the origin"** physics revealed by anisotropic σ

## Motivation

The current implementation has several limitations for multi-pair analysis:

### Current State

1. **`get_bell_state_parameters`**: Only works for n_pairs=1
2. **`rho_from_theta`**: Uses `expm(K)` on full D×D matrix — O(D³) = O(d^(6n)) for n pairs
3. **`fisher_information`**: Full eigendecomposition — O(D³), doesn't exploit block structure
4. **`marginal_entropy_constraint`**: Generic `partial_trace` — O(D²) per marginal
5. **No product structure exploitation**: For separable states, operations could factorise

### Scaling Problem

For n qutrit pairs (d=3):
- D = 9^n (Hilbert space dimension)
- Current Fisher information: O(9^(3n)) operations
- n=2: D=81, manageable
- n=3: D=729, slow  
- n=4: D=6561, impractical

### What's Needed

For the regularised product Bell state:
```
ρ_ε = (1-ε)|Ψ_origin⟩⟨Ψ_origin| + ε I/D
```
where |Ψ_origin⟩ = |Φ⟩⊗|Φ⟩⊗...⊗|Φ⟩:

1. **Eigenstructure is trivial**: 
   - One eigenvalue: λ₁ = (1-ε) + ε/D
   - D-1 eigenvalues: λ_rest = ε/D

2. **Fisher metric is block-diagonal**: G = diag(G₁, G₂, ..., Gₙ) for product states

3. **Marginals factorise**: Each pair has marginals I/d, independent of others

## Detailed Description

### 1. Whole-System Regularisation with Configurable σ

Instead of regularising each pair separately:
```python
# WRONG: per-pair regularisation
rho_pair_k = (1-ε)|Φ⟩⟨Φ| + ε I/d²
rho_total = ⊗_k rho_pair_k  # NOT a rank-1 + identity structure
```

Use whole-system regularisation with configurable σ:
```python
# CORRECT: whole-system regularisation  
psi_origin = product_of_bell_states(n_pairs, d)
rho_pure = |psi_origin⟩⟨psi_origin|
rho_epsilon = (1-ε) * rho_pure + ε * sigma  # sigma defaults to I/D
```

### 1b. The Physical Meaning of σ (from entropy_time_paths.ipynb)

The regularisation matrix σ is **not** just a mathematical convenience—it encodes the **direction of approach** to the pure-state boundary:

- **North Pole Analogy**: The LME origin is like a coordinate singularity at the north pole. Many distinct trajectories (different "meridians") all converge to the same point when traced backwards.
- **Different σ = Different History**: Each choice of σ represents a different path through state space that shares the same asymptotic pure-state origin.
- **Isotropic σ = I/D is "boring"**: The symmetric choice hides the rich tangent cone of possible departures.
- **Anisotropic σ reveals physics**: Different σ give different entropy-time flow directions, representing genuinely different dynamics.

### 1c. Constraints on Valid σ

σ must be a valid density matrix:
- **Hermitian**: σ = σ†
- **Positive semidefinite**: All eigenvalues ≥ 0
- **Unit trace**: Tr(σ) = 1

```python
def validate_sigma(sigma: np.ndarray, D: int) -> Tuple[bool, str]:
    """Validate σ is a valid density matrix."""
    if sigma.shape != (D, D):
        return False, f"Shape mismatch: expected ({D}, {D}), got {sigma.shape}"
    if not np.allclose(sigma, sigma.conj().T):
        return False, "σ must be Hermitian"
    eigvals = np.linalg.eigvalsh(sigma)
    if np.any(eigvals < -1e-10):
        return False, f"σ must be PSD, min eigenvalue: {eigvals.min()}"
    if not np.isclose(np.trace(sigma), 1.0):
        return False, f"Tr(σ) must be 1, got {np.trace(sigma)}"
    return True, "Valid"
```

### 1d. Impact of σ on Computational Efficiency

| σ type | Eigenstructure | Fisher metric | Efficiency |
|--------|---------------|---------------|------------|
| `I/D` (isotropic) | Trivial (2 distinct eigenvalues) | Block-diagonal | **Full O(n)** |
| `⊗ᵢ σᵢ` (product) | Analytic if each σᵢ simple | Block-diagonal | **Partial O(n·d⁴)** |
| `|ψ⟩⟨ψ|` (pure, product) | Rank-2, analytic | Block + coupling | **Partial** |
| `|ψ⟩⟨ψ|` (pure, entangled) | Rank-2, analytic | Full coupling | **Lost** |
| General σ | Full eigendecomp needed | Full computation | **Lost O(D³)** |

**Strategy**: Accept any valid σ, but detect structure and warn if efficiency assumptions are broken:

```python
def detect_sigma_structure(sigma, n_pairs, d) -> str:
    """Detect structure of σ for efficiency optimisation."""
    D = d ** (2 * n_pairs)
    
    # Check if isotropic
    if np.allclose(sigma, np.eye(D) / D):
        return 'isotropic'  # Full efficiency
    
    # Check if product state
    if is_product_state(sigma, n_pairs, d):
        return 'product'  # Partial efficiency
    
    # Check if rank-1 (pure state)
    if np.linalg.matrix_rank(sigma, tol=1e-10) == 1:
        return 'pure'  # Some analytic formulas apply
    
    return 'general'  # Fall back to generic computation
```

### 1e. Physics vs Efficiency Trade-off: Does Product σ Limit Interesting Dynamics?

**Important question**: Does restricting to product σ = σ₁⊗...⊗σₙ eliminate interesting multi-pair physics?

**What couples pairs in the inaccessible game?**

The constraint C = Σᵢ hᵢ (sum of ALL marginal entropies) couples pairs through:
- The gradient a = ∇C involves information from all pairs
- The projection Π_∥ = I - aa^T/||a||² mixes information across pairs  
- Even starting from a product state, the dynamics CAN create correlations

**But at the LME origin, ∇C ≈ 0 (the "boring" property)!**

Near the pure Bell origin:
- Π_∥ ≈ I regardless of σ choice
- Pairs evolve almost independently initially
- Inter-pair correlations emerge slowly as the system moves away from origin

**What σ actually controls:**

| σ type | Initial departure | Inter-pair correlation at t=0 | How correlations grow |
|--------|------------------|-------------------------------|----------------------|
| Isotropic I/D | Symmetric | None | Slow (symmetric) |
| Product σ₁⊗...⊗σₙ | Per-pair directions | None | Slow (asymmetric) |
| Entangled σ | Coupled directions | **Built-in from start** | Can be fast |

**The physics interpretation:**

- **Product σ**: You're asking "what happens if pairs depart the origin independently?"
  - Efficient O(n) computation
  - Inter-pair correlations emerge through constraint dynamics
  - Appropriate for studying how correlations develop from uncorrelated initial conditions

- **Entangled σ**: You're asking "what if the perturbation/noise itself couples pairs?"
  - Expensive O(D³) computation  
  - Inter-pair correlations present from the start
  - Appropriate for studying correlated noise/decoherence scenarios

**The genuine trade-off:**

Efficiency requires assuming pairs depart independently. This is a **physics assumption**, not just a computational shortcut:

```
Efficient (product σ)     ←→     Rich initial correlations (entangled σ)
     O(n) scaling                        O(D³) scaling
  Pairs depart independently         Departure itself couples pairs
  Correlations emerge dynamically    Correlations built into regularisation
```

**When to use which:**

1. **Product σ (efficient)**: Study emergence of correlations from the constraint dynamics
2. **Entangled σ (expensive)**: Study scenarios with pre-existing inter-pair coupling
3. **Isotropic σ = I/D**: Maximally symmetric baseline (the "boring" but clean reference)

### 2. Analytic θ for Regularised Product States

For ρ_ε = (1-ε)|Ψ⟩⟨Ψ| + ε I/D:
```
log(ρ_ε) = log(λ₁)|Ψ⟩⟨Ψ| + log(λ_rest)(I - |Ψ⟩⟨Ψ|)
         = log(ε/D) I + [log(λ₁) - log(λ_rest)]|Ψ⟩⟨Ψ|
```

The natural parameters θ_a = Tr(log(ρ_ε) F_a) / Tr(F_a²) can be computed analytically:
```
θ_a = [log(λ₁) - log(λ_rest)] × ⟨Ψ|F_a|Ψ⟩ / Tr(F_a²)
```

For product |Ψ⟩ and operators F_a^(k) acting on pair k:
```
⟨Ψ|F_a^(k)|Ψ⟩ = ⟨Φ|F_a|Φ⟩  (independent of k)
```

### 3. Block-Diagonal Fisher Information

For product states, the Fisher metric decomposes:
```
G = diag(G₁, G₂, ..., Gₙ)
```
where each Gₖ is the (d⁴-1)×(d⁴-1) Fisher metric for pair k.

**Efficient computation**:
- Compute G_single for one pair: O(d^12)
- Replicate n times: O(n × d^12)
- Total: O(n × d^12) instead of O(d^(6n))

### 4. Efficient Marginal Entropies

For |Ψ⟩ = ⊗_k |Φ_k⟩, each subsystem marginal is:
```
ρ_i = I/d  for all i
h_i = log(d)  for all i
C = 2n × log(d)
```

No need for explicit partial traces.

### 5. API Extensions

```python
class QuantumExponentialFamily:
    
    def get_product_bell_parameters(
        self,
        epsilon: float = 1e-6,
        log_epsilon: Optional[float] = None,
        bell_indices: Optional[List[int]] = None,
        # --- Regularisation direction options (mutually exclusive) ---
        sigma: Optional[np.ndarray] = None,           # Full D×D matrix (any structure)
        sigma_per_pair: Optional[List[np.ndarray]] = None,  # [σ₁,...,σₙ] for efficiency
    ) -> np.ndarray:
        """
        Natural parameters for regularised product of Bell states.
        
        Parameters
        ----------
        epsilon : float
            Regularisation strength (ε in ρ_ε = (1-ε)ρ_pure + ε σ)
        log_epsilon : float, optional
            Alternative: specify log(ε) for very small ε
        bell_indices : list of int, optional
            Which Bell state (k=0,...,d-1) for each pair
            
        sigma : ndarray, optional
            Full D×D regularisation matrix. Any valid density matrix.
            - Flexible but potentially expensive O(D³)
            - Use for entangled σ (inter-pair correlations in perturbation)
            
        sigma_per_pair : list of ndarray, optional  
            List of n density matrices, each d²×d² for one pair.
            Constructs σ = σ₁⊗σ₂⊗...⊗σₙ (product structure).
            - Efficient O(n) computation preserved
            - Use when pairs should depart independently
            
        If neither provided: uses I/D (isotropic, maximally efficient)
            
        Returns
        -------
        theta : ndarray
            Natural parameters for the regularised state
            
        Raises
        ------
        ValueError
            If both sigma and sigma_per_pair provided
            If sigma_per_pair has wrong length or shapes
            
        Warns
        -----
        UserWarning
            If sigma is provided but appears to be a product state
            (suggest using sigma_per_pair for efficiency)
        """
    
    def fisher_information_product(
        self,
        theta: np.ndarray,
        sigma_structure: str = 'auto',  # 'isotropic', 'product', 'general', 'auto'
    ) -> np.ndarray:
        """
        Fisher information exploiting product structure.
        
        Returns block-diagonal matrix when state is separable and 
        sigma_structure allows. Falls back to full computation otherwise.
        """
    
    def is_product_state(self, theta: np.ndarray, tol: float = 1e-6) -> bool:
        """Check if θ represents a product state (within tolerance)."""
    
    def is_product_sigma(self, sigma: np.ndarray, tol: float = 1e-6) -> bool:
        """Check if σ has product structure σ₁⊗...⊗σₙ."""
    
    def validate_sigma(self, sigma: np.ndarray) -> Tuple[bool, str]:
        """Validate σ is a valid density matrix of correct dimension."""
    
    def validate_sigma_per_pair(
        self, sigma_per_pair: List[np.ndarray]
    ) -> Tuple[bool, str]:
        """Validate list of per-pair σ matrices."""


def regularise_pure_state(
    psi: np.ndarray, 
    epsilon: float,
    sigma: Optional[np.ndarray] = None,
) -> np.ndarray:
    """
    Create regularised density matrix from pure state.
    
    ρ_ε = (1-ε)|ψ⟩⟨ψ| + ε σ
    
    Parameters
    ----------
    psi : ndarray
        Pure state vector
    epsilon : float
        Regularisation strength
    sigma : ndarray, optional
        Regularisation direction. Default: I/D (isotropic)
        
    Returns
    -------
    rho_epsilon : ndarray
        Regularised density matrix
    """
```

## Implementation Plan

### Phase 1: Core σ Infrastructure

1. **Add `validate_sigma(sigma, D)`**:
   - Check Hermitian, PSD, unit trace
   - Return (is_valid, error_message)

2. **Add `detect_sigma_structure(sigma, n_pairs, d)`**:
   - Return 'isotropic', 'product', 'pure', or 'general'
   - Used to select computation path

3. **Implement `regularise_pure_state(psi, epsilon, sigma=None)`**:
   - Create ρ_ε = (1-ε)|ψ⟩⟨ψ| + ε σ
   - Default σ = I/D

### Phase 2: Efficient Computation for Special σ

4. **Add `product_of_bell_states` with `bell_indices`**:
   - Allow different Bell states (k=0,1,...,d-1) per pair
   - Return both state vector and density matrix

5. **Implement analytic θ for rank-2 regularisation**:
   - Works for σ = I/D (isotropic) 
   - Works for σ = |ψ⟩⟨ψ| (pure state projector)
   - Both give rank-2 regularised state with analytic log

6. **Implement `get_product_bell_parameters` with sigma**:
   - Use analytic θ formula when σ structure permits
   - Fall back to logm for general σ
   - Warn if efficiency lost

7. **Implement `fisher_information_product`**:
   - Block-diagonal for isotropic σ
   - Detect and exploit product structure
   - Fall back to full computation

### Phase 3: Testing and Documentation

8. **Add tests**:
   - Verify analytic θ matches numeric logm (for all σ types)
   - Verify block-diagonal G matches full computation
   - Test scaling: n=1,2,3,4 pairs
   - Test different σ: isotropic, product, pure, general
   - Verify constraint gradient at origin

9. **Document the physics**:
   - "North pole analogy" from entropy_time_paths.ipynb
   - Different σ = different histories
   - When to use anisotropic σ

## Backward Compatibility

Fully backward compatible:
- Existing methods unchanged
- New methods are additions
- `get_bell_state_parameters` continues to work for n_pairs=1

## Testing Strategy

1. **Correctness tests**:
   - `get_product_bell_parameters` vs `logm` for small n
   - `fisher_information_product` vs `fisher_information` for small n
   - Verify ρ_from_theta(θ) ≈ ρ_ε

2. **Scaling tests**:
   - Time n=1,2,3,4 with both methods
   - Verify O(n) vs O(d^(6n)) scaling

3. **Physics tests**:
   - Constraint C = 2n log(d) at origin
   - Gradient a ≈ 0 at origin
   - Block structure of G

## Implementation Status

### Phase 1: Core σ Infrastructure ✅ COMPLETED (2025-12-07)
- [x] Implement `validate_sigma(sigma)` method
- [x] Implement `detect_sigma_structure(sigma)` method  
- [x] Implement `regularise_pure_state(psi, epsilon, sigma)` method
- [x] Implement `is_product_sigma(sigma)` method for product detection
- [x] Implement `_partial_trace_to_pair(sigma, pair_idx)` helper
- [x] Update `get_bell_state_parameters()` with sigma and sigma_per_pair parameters
- [x] Add efficiency warning when general σ used

### Phase 2: Multi-pair Support ✅ COMPLETED (2025-12-07)
- [x] Extend `get_bell_state_parameters` for n_pairs > 1
- [x] Analytic θ for isotropic σ = I/D (works for any n_pairs)
- [x] Product σ detection (falls back to general for now)
- [x] General σ with efficiency warning
- [x] Docstring explaining projection onto operator subspace
- [x] `fisher_information_product` with block structure
- [x] `_partial_trace_to_pair` using einsum for correctness
- [x] `_is_product_state` check for validation
- [x] `_fisher_block` for single-pair BKM computation
- [x] Optimised `get_bell_state_parameters` for product σ via `sigma_per_pair`
- [x] `_bell_parameters_product_sigma` for O(n × d⁶) computation
- [x] `product_of_bell_states` with `bell_indices` parameter
- [x] `bell_state(d, k)` for k-th Bell state (k=0,...,d-1)

### Phase 3: Testing ✅ COMPLETED (2025-12-07)
- [x] Test `validate_sigma` with valid/invalid inputs
- [x] Test `detect_sigma_structure` for all σ types
- [x] Verify analytic θ matches numeric logm (all σ types)
- [x] Verify block-diagonal G matches full computation (n=1,2,3)
- [x] Test scaling: n=1,2,3,4 pairs with isotropic σ
- [x] Test anisotropic σ gives different θ directions
- [x] Test `fisher_information_product` matches `fisher_information`
- [x] Test block-diagonal structure verified (off-diagonal blocks zero)
- [x] Test `_partial_trace_to_pair` correctness for n=1,2,3

### Phase 4: Documentation ✅ COMPLETED (2025-12-07)
- [x] Document σ validation requirements
- [x] Document efficiency implications of σ choice
- [x] Add "north pole analogy" explanation
- [x] Reference entropy_time_paths.ipynb analysis
- [x] Create docs/source/theory/regularisation.rst
- [x] Add block-diagonal Fisher information documentation
- [x] Add bell_indices documentation

## References

### Code
- `qig/exponential_family.py`: Current implementation
- `qig/pair_operators.py`: `multi_pair_basis`, `product_of_bell_states`
- `qig/core.py`: `partial_trace`, `marginal_entropies`

### Notebooks
- `examples/entropy_time_paths.ipynb`: **Key analysis** showing:
  - The "north pole analogy" - LME origin as coordinate singularity
  - Different σ = different "meridians" / histories
  - Isotropic σ = I/D gives "boring" dynamics due to symmetry
  - Anisotropic σ reveals rich tangent cone of departures
  - L'Hôpital-style limits in entropy time give well-defined directions
- `examples/boring_game_dynamics.ipynb`: Shows boring dynamics with isotropic σ

### Documentation
- `docs/entropy_time_analysis.md`: Analysis motivating this work

### Paper (the-inaccessible-game-origin.tex)
- **Extensivity principle** (line ~1599): "By extensivity (additivity over disjoint subsystems), the entropy production rate decomposes as Ḣ(ε) = (n/2) · Ḣ_pair(ε; d)"
- **Product structure** (line ~1599): "the global state factorises as a product of n/2 independent maximally entangled pairs"
- **Regularisation** (line ~641-643): "always understood in a regularised sense for states arbitrarily close to, but not exactly at, the boundary"
- **Eigenvalue scaling** (line ~554-555): "if the smallest nonzero eigenvalue of ρ is ε, the leading divergence behaves like -log ε"
