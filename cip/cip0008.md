---
author: "Neil Lawrence"
created: "2025-12-06"
id: "0008"
last_updated: "2025-12-06"
status: proposed
tags:
- cip
- multi-pair
- regularisation
- efficiency
- product-states
title: "Efficient Multi-Pair Origin Machinery with Whole-System Regularisation"
---

# CIP-0008: Efficient Multi-Pair Origin Machinery with Whole-System Regularisation

## Summary

Extend the quantum exponential family machinery to efficiently handle multi-pair product states at the inaccessible game origin, with whole-system regularisation and exploitation of tensor product structure.

## Motivation

The current implementation has several limitations for multi-pair analysis:

### Current State

1. **`get_bell_state_parameters`**: Only works for n_pairs=1
2. **`rho_from_theta`**: Uses `expm(K)` on full D×D matrix — O(D³) = O(d^(6n)) for n pairs
3. **`fisher_information`**: Full eigendecomposition — O(D³), doesn't exploit block structure
4. **`marginal_entropy_constraint`**: Generic `partial_trace` — O(D²) per marginal
5. **No product structure exploitation**: For separable states, operations could factorise

### Scaling Problem

For n qutrit pairs (d=3):
- D = 9^n (Hilbert space dimension)
- Current Fisher information: O(9^(3n)) operations
- n=2: D=81, manageable
- n=3: D=729, slow  
- n=4: D=6561, impractical

### What's Needed

For the regularised product Bell state:
```
ρ_ε = (1-ε)|Ψ_origin⟩⟨Ψ_origin| + ε I/D
```
where |Ψ_origin⟩ = |Φ⟩⊗|Φ⟩⊗...⊗|Φ⟩:

1. **Eigenstructure is trivial**: 
   - One eigenvalue: λ₁ = (1-ε) + ε/D
   - D-1 eigenvalues: λ_rest = ε/D

2. **Fisher metric is block-diagonal**: G = diag(G₁, G₂, ..., Gₙ) for product states

3. **Marginals factorise**: Each pair has marginals I/d, independent of others

## Detailed Description

### 1. Whole-System Regularisation

Instead of regularising each pair separately:
```python
# WRONG: per-pair regularisation
rho_pair_k = (1-ε)|Φ⟩⟨Φ| + ε I/d²
rho_total = ⊗_k rho_pair_k  # NOT a rank-1 + identity structure
```

Use whole-system regularisation:
```python
# CORRECT: whole-system regularisation  
psi_origin = product_of_bell_states(n_pairs, d)
rho_pure = |psi_origin⟩⟨psi_origin|
rho_epsilon = (1-ε) * rho_pure + ε * I/D
```

### 2. Analytic θ for Regularised Product States

For ρ_ε = (1-ε)|Ψ⟩⟨Ψ| + ε I/D:
```
log(ρ_ε) = log(λ₁)|Ψ⟩⟨Ψ| + log(λ_rest)(I - |Ψ⟩⟨Ψ|)
         = log(ε/D) I + [log(λ₁) - log(λ_rest)]|Ψ⟩⟨Ψ|
```

The natural parameters θ_a = Tr(log(ρ_ε) F_a) / Tr(F_a²) can be computed analytically:
```
θ_a = [log(λ₁) - log(λ_rest)] × ⟨Ψ|F_a|Ψ⟩ / Tr(F_a²)
```

For product |Ψ⟩ and operators F_a^(k) acting on pair k:
```
⟨Ψ|F_a^(k)|Ψ⟩ = ⟨Φ|F_a|Φ⟩  (independent of k)
```

### 3. Block-Diagonal Fisher Information

For product states, the Fisher metric decomposes:
```
G = diag(G₁, G₂, ..., Gₙ)
```
where each Gₖ is the (d⁴-1)×(d⁴-1) Fisher metric for pair k.

**Efficient computation**:
- Compute G_single for one pair: O(d^12)
- Replicate n times: O(n × d^12)
- Total: O(n × d^12) instead of O(d^(6n))

### 4. Efficient Marginal Entropies

For |Ψ⟩ = ⊗_k |Φ_k⟩, each subsystem marginal is:
```
ρ_i = I/d  for all i
h_i = log(d)  for all i
C = 2n × log(d)
```

No need for explicit partial traces.

### 5. API Extensions

```python
class QuantumExponentialFamily:
    
    def get_product_bell_parameters(
        self,
        epsilon: float = 1e-6,
        log_epsilon: Optional[float] = None,
        bell_indices: Optional[List[int]] = None,
    ) -> np.ndarray:
        """
        Natural parameters for regularised product of Bell states.
        
        Uses whole-system regularisation and analytic formulas.
        Works for any n_pairs.
        """
    
    def fisher_information_product(
        self,
        theta: np.ndarray,
    ) -> np.ndarray:
        """
        Fisher information exploiting product structure.
        
        Returns block-diagonal matrix when state is separable.
        Falls back to full computation otherwise.
        """
    
    def is_product_state(self, theta: np.ndarray, tol: float = 1e-6) -> bool:
        """Check if θ represents a product state (within tolerance)."""
```

## Implementation Plan

1. **Add `product_of_bell_states` with `bell_indices`**:
   - Allow different Bell states (k=0,1,...,d-1) per pair
   - Return both state vector and density matrix

2. **Implement whole-system regularisation**:
   - `regularise_pure_state(psi, epsilon)` → ρ_ε
   - Analytic formula using rank-1 + identity structure

3. **Implement `get_product_bell_parameters`**:
   - Use analytic θ formula
   - No matrix logarithm needed
   - Works for any n_pairs

4. **Implement `fisher_information_product`**:
   - Detect product structure from `pair_indices`
   - Compute single-pair Fisher metric
   - Construct block-diagonal result

5. **Optimise `marginal_entropy_constraint` for products**:
   - Fast path when state is detected as product
   - Return analytic gradient

6. **Add tests**:
   - Verify analytic θ matches numeric logm
   - Verify block-diagonal G matches full computation
   - Test scaling: n=1,2,3,4 pairs
   - Verify constraint gradient at origin

## Backward Compatibility

Fully backward compatible:
- Existing methods unchanged
- New methods are additions
- `get_bell_state_parameters` continues to work for n_pairs=1

## Testing Strategy

1. **Correctness tests**:
   - `get_product_bell_parameters` vs `logm` for small n
   - `fisher_information_product` vs `fisher_information` for small n
   - Verify ρ_from_theta(θ) ≈ ρ_ε

2. **Scaling tests**:
   - Time n=1,2,3,4 with both methods
   - Verify O(n) vs O(d^(6n)) scaling

3. **Physics tests**:
   - Constraint C = 2n log(d) at origin
   - Gradient a ≈ 0 at origin
   - Block structure of G

## Implementation Status

- [ ] Extend `product_of_bell_states` with `bell_indices`
- [ ] Implement `regularise_pure_state` function
- [ ] Implement analytic θ for regularised pure states
- [ ] Implement `get_product_bell_parameters` for any n_pairs
- [ ] Implement `is_product_state` detection
- [ ] Implement `fisher_information_product` with block structure
- [ ] Optimise `marginal_entropy_constraint` for product states
- [ ] Add unit tests for correctness
- [ ] Add scaling tests
- [ ] Update documentation

## References

- `qig/exponential_family.py`: Current implementation
- `qig/pair_operators.py`: `multi_pair_basis`, `product_of_bell_states`
- `qig/core.py`: `partial_trace`, `marginal_entropies`
- `docs/entropy_time_analysis.md`: Analysis motivating this work
