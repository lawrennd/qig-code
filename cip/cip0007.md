---
author: "Neil Lawrence / AI Assistant"
created: "2025-12-01"
id: "0007"
last_updated: "2025-12-02"
status: in_progress
tags:
- cip
- symbolic-computation
- lie-algebra
- generic-decomposition
- quantum
- su9-pair-basis
title: "Analytic Forms for S and A via Lie Algebra Structure"
---

# CIP-0007: Analytic Forms for S and A via Lie Algebra Structure

## Summary

Develop symbolic/analytic expressions for the symmetric (S) and antisymmetric (A) 
parts of the GENERIC decomposition Jacobian for quantum systems using Lie-algebraic 
operator bases. Similar to the harmonic oscillator implementation which has 
`antisymmetric_part_analytical(theta)`, create analytic forms for the quantum 
qutrit case that exploit structure constants and block structure to achieve 
significant simplifications.

## Motivation

**Current state**: The quantum implementation computes S and A purely numerically 
by decomposing the full Jacobian M computed via automatic differentiation:
```python
M = self.jacobian(theta, method='duhamel')  # Numerical
S = 0.5 * (M + M.T)
A = 0.5 * (M - M.T)
```

**Problems**:
1. Numerical computation obscures geometric structure
2. Third derivatives of œà are expensive to compute numerically
3. Cannot directly see how Lie algebra structure creates simplifications
4. Difficult to verify theoretical properties analytically

**Opportunity**: The Lie-algebraic structure provides multiple sources of 
simplification that aren't exploited:

1. **Structure constants**: Commutation relations [F_a, F_b] = 2i Œ£_c f_abc F_c 
   create systematic zeros when operators act on different sites

2. **Block structure**: For independent pairs at LME origin, all geometric objects 
   (G, a, M, S, A) decompose into independent blocks

3. **Analytic formula for A**: From equation (283) in quantum-generic-decomposition.tex:
   ```
   A = (1/2)[a‚äó(‚àáŒΩ)·µÄ - (‚àáŒΩ)‚äóa·µÄ]
   ```
   This is *simpler* than the full Jacobian‚Äîit only depends on constraint geometry

4. **Tensor contractions with structure constants**: Third derivatives of œà interact 
   with f_abc in ways that should produce cancellations

**Evidence from classical case**: The harmonic oscillator (3 parameters) has 
analytic forms computed via SymPy that reveal the geometric structure as 
polynomial ratios. Despite complexity (degree-7 denominators), these expressions:
- Validate numerical implementations to machine precision
- Reveal factored structures (e.g., A_12 = -4Œ∏_pp Œ∏_xp¬≤ Œ∏_xx (Œ∏_pp¬≤ - Œ∏_xx¬≤)(...) / D¬≤)
- Enable symbolic verification of properties (Jacobi identity, etc.)

**Goal**: Achieve the same for quantum systems, focusing on:
- Single qutrit pair (2 qutrits, 16 parameters)
- Exploiting Lie structure for simplifications beyond what classical case has
- Creating reusable symbolic computation infrastructure

## Detailed Description

### Mathematical Foundation

The antisymmetric part has an explicit geometric form:
```
A = (1/2)[a(‚àáŒΩ)·µÄ - (‚àáŒΩ)a·µÄ]
```

where:
- `a = ‚àá(Œ£_i h_i)` is the constraint gradient (marginal entropies)
- `ŒΩ = (a·µÄGŒ∏)/(a·µÄa)` is the Lagrange multiplier
- `‚àáŒΩ` involves third derivatives of œà, constraint Hessian, and metric contractions

**Key insight**: This formula is *independent of most of the Jacobian complexity*. 
We don't need to compute the full M symbolically‚Äîonly the constraint geometry 
(a, ŒΩ, ‚àáŒΩ).

### Lie Algebra Simplifications

For Gell-Mann basis {Œª_k} on two qutrits:

**Structure constants block pattern**:
```
f_abc = 0  when F_a and F_b act on different sites
```
This means:
- f_abc ‚â† 0 only for indices (a,b,c) all ‚â§ 8 (site 1) or all > 8 (site 2)
- Cross-site terms vanish automatically
- The 16√ó16√ó16 structure constant tensor is extremely sparse

**Block structure at LME origin**:
For product state œÅ = œÅ‚ÇÅ ‚äó œÅ‚ÇÇ:
```
G_total = G‚ÇÅ ‚äï G‚ÇÇ    (block diagonal)
a_total = a‚ÇÅ ‚äï a‚ÇÇ    (block separable)
A_total = A‚ÇÅ ‚äï A‚ÇÇ    (block diagonal)
```

**Implication**: We only need to compute A for a *single* pair (8√ó8 matrix), 
then assemble via direct sum. Reduces 16√ó16 problem to 8√ó8.

### Computational Strategy

**Phase 1**: Single-site symbolic computation
- Start with single qutrit (8 parameters)
- Compute œà(Œ∏) symbolically for small perturbations from maximally mixed state
- Derive G = ‚àá¬≤œà symbolically
- Test if expressions simplify using structure constants

**Phase 2**: Single-pair symbolic computation  
- Two qutrits (16 parameters) with block structure
- Use SymPy to compute:
  - Marginal entropies h‚ÇÅ(Œ∏), h‚ÇÇ(Œ∏)
  - Constraint gradient a = ‚àá(h‚ÇÅ + h‚ÇÇ)
  - Lagrange multiplier ŒΩ(Œ∏)
  - Gradient ‚àáŒΩ(Œ∏) using quotient rule and chain rule
- Assemble A = (1/2)[a‚äó(‚àáŒΩ)·µÄ - (‚àáŒΩ)‚äóa·µÄ]
- Check for factorizations and simplifications

**Phase 3**: Numerical validation
- Generate test cases spanning parameter space
- Compare symbolic expressions to numerical computation
- Validate to machine precision (< 1e-12)

**Phase 4**: Implementation
- Convert SymPy expressions to NumPy-evaluable functions
- Create `antisymmetric_part_analytical_qutrit(theta)`
- Create `symmetric_part_analytical_qutrit(theta)` (S = M - A where M is from 
  direct formula)
- Add to `qig.analytic` module

## Implementation Plan

### 1. Setup Symbolic Infrastructure

**Task 1.1**: Create symbolic computation module
- File: `qig/symbolic/__init__.py`
- File: `qig/symbolic/qutrit_analytic.py`
- Dependencies: sympy, numpy
- Basic structure:
  ```python
  import sympy as sp
  from sympy import symbols, Matrix, exp, log, simplify
  
  def symbolic_gell_mann_matrices():
      """Return symbolic 3√ó3 Gell-Mann matrices"""
      ...
  
  def symbolic_structure_constants():
      """Return symbolic f_abc for su(3)"""
      ...
  ```

**Task 1.2**: Symbolic density matrix for single qutrit
- Function: `symbolic_rho_single_qutrit(theta_symbols)`
- Compute: œÅ = exp(Œ£ Œ∏_k Œª_k) / Z symbolically
- Test: Verify Tr(œÅ) = 1, œÅ‚Ä† = œÅ symbolically

**Task 1.3**: Symbolic von Neumann entropy
- Function: `symbolic_von_neumann_entropy(rho_sym)`
- Handle: Eigenvalue decomposition symbolically (challenging!)
- Alternative: Series expansion around maximally mixed state
- Test: Compare to numerical for simple cases

**Validation**: 
- [ ] Symbolic Gell-Mann matrices match numerical to 1e-15
- [ ] Symbolic structure constants match reference values
- [ ] Symbolic œÅ satisfies normalization and Hermiticity

### 2. Single-Qutrit Analytic Forms

**Task 2.1**: BKM metric G for single qutrit
- Function: `symbolic_fisher_single_qutrit(theta_symbols)`
- Compute: G_ij = ‚àÇ¬≤œà/‚àÇŒ∏_i‚àÇŒ∏_j
- Simplify using SymPy's simplify, factor, cancel

**Task 2.2**: Marginal entropy (degenerate case)
- For single qutrit: h = H (joint = marginal)
- Constraint gradient: a = ‚àáH
- Simplify and look for structure

**Task 2.3**: Document single-qutrit structure
- What patterns emerge?
- Do structure constants create simplifications?
- Export as reference for two-qutrit case

**Validation**:
- [ ] Symbolic G matches numerical G for 10 random Œ∏ (tol < 1e-10)
- [ ] G is symmetric positive definite symbolically
- [ ] ‚àáH matches numerical gradient (tol < 1e-10)

### 3. Two-Qutrit Antisymmetric Part

**Task 3.1**: Symbolic two-qutrit density matrix
- Function: `symbolic_rho_two_qutrit(theta_symbols)`
- Use: œÅ = exp(Œ£‚ÇÅ‚ÇÜ Œ∏_a F_a - œà) where F_a are tensor products
- Exploit: Block structure (operators 1-8 on site 1, 9-16 on site 2)

**Task 3.2**: Marginal entropies h‚ÇÅ, h‚ÇÇ
- Compute: œÅ‚ÇÅ = Tr‚ÇÇ(œÅ), œÅ‚ÇÇ = Tr‚ÇÅ(œÅ)
- Compute: h‚ÇÅ = -Tr(œÅ‚ÇÅ log œÅ‚ÇÅ), h‚ÇÇ = -Tr(œÅ‚ÇÇ log œÅ‚ÇÇ)
- Challenge: Partial traces and logs are expensive symbolically
- Strategy: Use perturbative expansion around LME state

**Task 3.3**: Constraint gradient a
- Compute: a = ‚àá(h‚ÇÅ + h‚ÇÇ)
- Exploit: Separability (a_k depends only on local marginal for k in that site)
- Simplify using chain rule and structure

**Task 3.4**: Lagrange multiplier ŒΩ
- Compute: ŒΩ = (a·µÄGŒ∏)/(a·µÄa)
- Requires: G from Task 2.1 (extended to 16D)
- Simplify the rational expression

**Task 3.5**: Gradient ‚àáŒΩ (the hard part!)
- Use quotient rule: ‚àá(u/v) = (v‚àáu - u‚àáv)/v¬≤
- Need: ‚àá(a·µÄGŒ∏) which requires:
  - (‚àáa)·µÄGŒ∏ + a·µÄ(‚àáG)[Œ∏] + a·µÄG
  - Where (‚àáG)[Œ∏]_ij = Œ£_k (‚àÇG_ij/‚àÇŒ∏_k)Œ∏_k = third derivatives of œà
- Need: ‚àá(a·µÄa) = 2(‚àáa)·µÄa
- This is equation (238-239) from quantum-generic-decomposition.tex

**Task 3.6**: Assemble A
- Compute: A = (1/2)[a(‚àáŒΩ)·µÄ - (‚àáŒΩ)a·µÄ]
- This is 16√ó16 antisymmetric matrix with symbolic entries
- Simplify each entry

**Task 3.7**: Check for block structure
- Verify: A has block-diagonal structure for product states
- Identify: Which terms couple sites vs. stay local
- Document: Structure in comments

**Validation**:
- [ ] Each step: symbolic vs numerical (tol < 1e-10)
- [ ] A is antisymmetric: A + A·µÄ = 0 symbolically
- [ ] Degeneracy: A¬∑(-GŒ∏) ‚âà 0 numerically (tol < 1e-6)
- [ ] Full expression validates against 20 random Œ∏ states

### 4. Symmetric Part and Full Jacobian

**Task 4.1**: Full Jacobian M from formula
- Use: M = -G - (‚àáG)[Œ∏] + ŒΩ‚àá¬≤C + a(‚àáŒΩ)·µÄ
- We have: G, ‚àáG (from third derivatives), ŒΩ, ‚àáŒΩ, a
- Need: Constraint Hessian ‚àá¬≤C = ‚àá¬≤(h‚ÇÅ + h‚ÇÇ)

**Task 4.2**: Symmetric part
- Compute: S = (1/2)(M + M·µÄ)
- Alternatively: S = M - A (since M = S + A)
- Compare both methods for consistency

**Task 4.3**: Verify GENERIC structure
- Check: S¬∑a ‚âà 0 (degeneracy condition)
- Check: S positive semi-definite on tangent space
- Check: M = S + A exactly

**Validation**:
- [ ] S is symmetric: S - S·µÄ = 0 symbolically
- [ ] S¬∑a ‚âà 0 numerically (tol < 1e-6)
- [ ] Full M = S + A matches numerical Jacobian (tol < 1e-10)

### 5. Code Generation and Optimization

**Task 5.1**: Convert to evaluable functions
- Use: `sympy.lambdify` to create NumPy functions
- Optimize: Use `cse=True` for common subexpression elimination
- Structure:
  ```python
  # Generated by symbolic computation
  def _a_single_qutrit(theta):
      Œ∏1, Œ∏2, Œ∏3, Œ∏4, Œ∏5, Œ∏6, Œ∏7, Œ∏8 = theta
      # ... generated code ...
      return np.array([...])
  
  def antisymmetric_part_analytical_qutrit(theta):
      """
      Analytic antisymmetric part for two-qutrit system.
      
      Uses exact symbolic computation exploiting Lie algebra structure.
      Validated against numerical computation to machine precision.
      """
      a = _a_two_qutrit(theta)
      grad_nu = _grad_nu_two_qutrit(theta)
      A = 0.5 * (np.outer(a, grad_nu) - np.outer(grad_nu, a))
      return A
  ```

**Task 5.2**: Performance optimization
- Profile: Compare runtime vs numerical approach
- Optimize: Factor out common subexpressions manually if needed
- Cache: Precompute constant symbolic matrices

**Task 5.3**: Add to qig.analytic module
- File: `qig/analytic/__init__.py`
- File: `qig/analytic/qutrit.py`
- Export: Functions for use by other modules
- Document: Include LaTeX rendering of key formulas in docstrings

**Validation**:
- [ ] Generated functions match symbolic computation
- [ ] Performance: within 2√ó of numerical for single evaluation
- [ ] Memory: reasonable (< 100 MB for function definitions)

### 6. Comprehensive Testing

**Task 6.1**: Unit tests for symbolic module
- File: `tests/test_symbolic_qutrit.py`
- Test symbolic Gell-Mann matrices
- Test symbolic structure constants
- Test symbolic œÅ properties

**Task 6.2**: Validation tests against numerics
- File: `tests/test_analytic_qutrit_validation.py`
- Generate 100 random Œ∏ states spanning parameter space
- For each state:
  - Compute A_analytic, S_analytic
  - Compute A_numeric, S_numeric (existing code)
  - Assert ||A_analytic - A_numeric|| < 1e-12
  - Assert ||S_analytic - S_numeric|| < 1e-12

**Task 6.3**: Property verification tests
- File: `tests/test_analytic_qutrit_properties.py`
- Test antisymmetry: A + A·µÄ = 0
- Test symmetry: S - S·µÄ = 0
- Test degeneracy conditions:
  - S¬∑a ‚âà 0 (within 1e-6)
  - A¬∑(-GŒ∏) ‚âà 0 (within 1e-6)
- Test GENERIC: M = S + A

**Task 6.4**: Block structure tests
- File: `tests/test_qutrit_block_structure.py`
- Test that A has expected block structure for separable states
- Test that single-pair computation matches direct sum assembly
- Verify sparsity patterns match theoretical predictions

**Task 6.5**: Integration tests
- Test analytic forms work in full GENERIC decomposition
- Test extraction of Hamiltonian coefficients Œ∑ from analytic A
- Compare full dynamics using analytic vs numeric S, A

**Task 6.6**: Regression tests
- Store 10 reference states with known A, S values (computed numerically)
- Test that analytic forms reproduce these to machine precision
- Ensures no regressions in future refactoring

**Validation**:
- [ ] All tests pass with strict tolerances
- [ ] Code coverage > 95% for new symbolic modules
- [ ] Integration with existing GenericDecomposition class works

### 7. Documentation and Examples

**Task 7.1**: Technical documentation
- File: `docs/source/technical/symbolic_computation.rst`
- Explain: Symbolic computation approach
- Document: Key simplifications from Lie algebra
- Show: Example derivations with LaTeX rendering

**Task 7.2**: API documentation
- Add comprehensive docstrings with:
  - Mathematical formulas (LaTeX in docstrings)
  - Parameter descriptions
  - Return value specs
  - Examples of usage
  - References to equations in quantum-generic-decomposition.tex

**Task 7.3**: Usage examples
- File: `examples/analytic_qutrit_generic.py`
- Demonstrate:
  - Computing A, S analytically
  - Comparing to numerical
  - Extracting Hamiltonian
  - Visualizing block structure

**Task 7.4**: Jupyter notebook
- File: `examples/symbolic_generic_decomposition.ipynb`
- Interactive exploration of:
  - How symbolic computation works
  - Visualizing simplifications from Lie structure
  - Numerical validation
  - Performance comparisons

**Validation**:
- [ ] Docs build successfully
- [ ] Examples run without errors
- [ ] Notebook executes top-to-bottom

### 8. Extension to Multi-Pair Systems

**Task 8.1**: Direct sum assembly
- Function: `antisymmetric_part_multipair(theta_list, n_pairs)`
- Use single-pair analytic forms
- Assemble via block-diagonal structure
- Validate extensivity

**Task 8.2**: Test scaling
- Verify linear scaling: n pairs ‚Üí n √ó (single pair cost)
- Not exponential: should be O(n¬∑d‚Å¥) not O(d^(4n))

**Validation**:
- [ ] Multi-pair matches direct computation for 2-4 pairs
- [ ] Scaling is linear in n_pairs
- [ ] Block structure preserved

## Backward Compatibility

**No breaking changes**: All new functionality is additive.

**Existing code unaffected**: The numerical implementation in 
`QuantumExponentialFamily.antisymmetric_part()` remains the default.

**Opt-in usage**: Users who want analytic forms import from `qig.analytic`:
```python
from qig.analytic import antisymmetric_part_analytical_qutrit

# Use analytic form
A = antisymmetric_part_analytical_qutrit(theta)

# Or continue using numerical
A = exp_fam.antisymmetric_part(theta)
```

**Future integration**: Once validated, could add `method='analytic'` parameter 
to existing methods:
```python
A = exp_fam.antisymmetric_part(theta, method='analytic')
```

## Testing Strategy

### Unit Testing
- **Symbolic module**: Test each symbolic computation function independently
- **Property tests**: Verify mathematical properties hold symbolically
- **Reference values**: Test against known SU(3) structure constants

### Validation Testing  
- **Cross-validation**: Compare analytic vs numerical for 100+ random states
- **Tolerance**: Require agreement to machine precision (< 1e-12)
- **Edge cases**: Test near pure states, highly mixed states, symmetric states

### Integration Testing
- **End-to-end**: Use analytic forms in full GENERIC decomposition
- **Consistency**: Results match numerical implementation
- **Hamiltonian extraction**: Œ∑ from analytic A matches numerical

### Performance Testing
- **Benchmark**: Compare evaluation time analytic vs numerical
- **Scaling**: Test that multi-pair scales linearly
- **Memory**: Monitor memory usage for large expressions

### Regression Testing
- **Golden outputs**: Store reference computations
- **CI integration**: Run all tests on every commit
- **Cross-platform**: Test on different NumPy/SymPy versions

## Challenges and Mitigation

### Challenge 1: Symbolic Entropy Computation

**Problem**: von Neumann entropy H = -Tr(œÅ log œÅ) requires eigendecomposition, 
which is difficult symbolically.

**BREAKTHROUGH: Block Structure of Reduced Density Matrices**

For our qutrit pair system (d=3), the reduced density matrices have special structure:
```
œÅ‚ÇÅ = [[a, b, 0],      (2√ó2 block + 1√ó1 block)
      [b, c, 0],
      [0, 0, d]]
```

This means eigenvalues come from **quadratic** (not cubic) formula:
- Œª‚ÇÉ = d (trivial - isolated entry)
- Œª‚ÇÅ,‚ÇÇ = (a+c ¬± ‚àö((a-c)¬≤ + 4b¬≤)) / 2

**Result**: 
- Differentiation: 0.08s (was MINUTES with general cubic eigenvalues)
- Accuracy: ratio to numerical = 1.0001 (essentially exact)
- No Taylor approximation needed for accuracy!

**Three methods available**:
1. **Exact with block structure** (`method='exact'`): Fast AND accurate ‚úì (DEFAULT)
2. **Taylor approximation** (`method='taylor'`): Fast, ~1% error
3. **General eigenvalues** (without block structure): Slow, avoid

**TODO: Sphinx documentation needed** - the block structure discovery is a key insight
that should be documented with mathematical derivation.

**Open question**: Does similar block structure exist for qubits (d=2) and 
higher-dimensional qudits? The current symbolic code is qutrit-specific.

### Challenge 2: Expression Complexity

**Problem**: Symbolic expressions may be extremely long (thousands of terms).

**Actual solution implemented**:
- **Aggressive caching**: Store computed expressions to disk (`_cache/*.pkl`)
- **Incremental building**: Compute a ‚Üí ŒΩ ‚Üí ‚àáŒΩ ‚Üí A in stages, cache each
- **Limited parameters**: Use 4-6 symbolic parameters, rest set to 0
- **Result**: Expressions manageable, ~30KB pickle files

### Challenge 3: Computation Time

**Problem**: Symbolic differentiation can be extremely slow (minutes to hours).

**CRITICAL mitigation - profile BEFORE running**:
```python
# ALWAYS estimate time before launching:
# - Density matrix (4 params): ~0.2s
# - Partial trace: ~0.2s
# - Eigenvalues 3√ó3: ~0.04s
# - Differentiate polynomial: ~0.05s/derivative
# - Differentiate log expression: MINUTES (avoid!)
```

**Incremental testing strategy**:
1. Run smallest possible test first (1 component, 1 point)
2. Use timeouts: `timeout 10 python -c "..."`
3. Check cache status before recomputing
4. Validate fixes with single-point comparisons, not full test suites

### Challenge 4: Validation Strategy

**Problem**: Full validation suite with 100 states takes too long interactively.

**Practical solution**:
1. **Quick sanity check** (~5s): One component at one Œ∏ value
   ```python
   ratio = a0_numerical / a0_symbolic  # Should be ~1.0
   ```
2. **Structural validation** (~30s): Check signs match, both non-zero
3. **Full validation** (offline): Run comprehensive tests as batch job

### Challenge 5: Approximation Transparency

**Problem**: Using approximations without clear labeling leads to confusion.

**Solution implemented**:
- Functions named `_taylor_` vs `_exact_` explicitly
- Docstrings state "APPROXIMATE" or "EXACT" prominently
- Comments include error bounds: "Error O(||Œ∏||‚Å¥)"
- Default alias points to practical choice with clear note

## Success Metrics

### Phase 1: Symbolic Infrastructure (2 weeks)
- [ ] All symbolic functions implemented and tested
- [ ] Single-qutrit analytic G validated to 1e-10

### Phase 2: Two-Qutrit A (3-4 weeks)
- [ ] Symbolic A formula derived and simplified
- [ ] Validates against numerical for 100 test cases (tol < 1e-12)
- [ ] Block structure matches theory

### Phase 3: Full S and M (2 weeks)
- [ ] Symmetric part S derived
- [ ] Full GENERIC structure verified
- [ ] All degeneracy conditions hold

### Phase 4: Code Generation (1 week)
- [ ] Functions generated and optimized
- [ ] Performance within 2√ó of numerical
- [ ] Integrated into qig.analytic module

### Phase 5: Documentation (1 week)
- [ ] Full API documentation
- [ ] Technical docs explain approach
- [ ] Examples and notebook complete

**Total estimated time**: 9-11 weeks for complete implementation

## Related Requirements

This CIP directly implements the "handle-turning exercise" described in:
- `/Users/neil/lawrennd/the-inaccessible-game-orgin/quantum-generic-decomposition.tex`

Specifically:
- Section 2: Gell-Mann generators (already have in code)
- Sections 3-9: Information geometry (have numerical, need symbolic)
- Section 10: Extract Hamiltonian from A (have via structure constants)
- Focus: Making Steps 5-9 symbolic for qutrits

Related to:
- **CIP-0006**: Implements the GENERIC decomposition numerically; this CIP makes it analytic
- **Quantum origin paper**: Validates the effective Hamiltonian derivation
- **Classical inaccessible game**: Provides template (harmonic oscillator analytic forms)

## Implementation Status

**Note**: Implementation uses su(9) PAIR basis (80 parameters) not local su(3)‚äósu(3) 
basis (16 parameters). The local basis gives A=0 due to structural identity GŒ∏=-a.
The pair basis breaks this identity, enabling A‚â†0.

### Phase 1: su(9) Symbolic Infrastructure ‚úÖ COMPLETE
- [x] Create `qig/symbolic/__init__.py`
- [x] Create `qig/symbolic/su9_pair.py` - main implementation
- [x] Create `qig/symbolic/cache.py` - disk caching for expensive computations
- [x] Symbolic su(9) generators (80 matrices, 9√ó9)
- [x] Symbolic su(9) structure constants
- [x] Verified: Hermiticity, tracelessness, normalization Tr(F_a F_b)=2Œ¥_ab
- [x] Verified: Commutation relations [F_a, F_b] = 2i Œ£_c f_abc F_c

### Phase 2: Pair Qutrit Analytic Forms ‚úÖ COMPLETE
- [x] Symbolic density matrix œÅ(Œ∏) via Taylor expansion
- [x] Symbolic partial trace (exact, no approximation)
- [x] Symbolic Fisher metric G = ‚àá¬≤œà
- [x] Symbolic von Neumann entropy (Taylor approximation, coefficient 3/2)
- [x] Clear naming: `_exact_` vs `_taylor_` functions

### Phase 3: Constraint Geometry ‚úÖ COMPLETE  
- [x] Marginal entropies h‚ÇÅ, h‚ÇÇ via partial trace
- [x] Constraint gradient a = ‚àá(h‚ÇÅ + h‚ÇÇ)
- [x] **KEY RESULT**: Structural identity GŒ∏ = -a is BROKEN for su(9) pair basis
- [x] Lagrange multiplier ŒΩ = (a·µÄGŒ∏)/(a·µÄa)
- [x] **KEY RESULT**: ŒΩ ‚â† -1 (complex rational function of Œ∏)
- [x] Gradient ‚àáŒΩ (quotient rule, cached)
- [x] **KEY RESULT**: ‚àáŒΩ ‚â† 0

### Phase 4: Antisymmetric Part ‚úÖ COMPLETE
- [x] Assemble A = (1/2)[a‚äó(‚àáŒΩ)·µÄ - (‚àáŒΩ)‚äóa·µÄ]
- [x] **KEY RESULT**: A ‚â† 0! Hamiltonian dynamics exist!
- [x] Validated: ratio(numerical/symbolic) = 1.000
- [x] Expressions exported to `qig/symbolic/results/symbolic_expressions_4params.py`

### Phase 5: Symmetric Part üî≤ PENDING
- [ ] Constraint Hessian ‚àá¬≤C
- [ ] Full Jacobian M = -G - (‚àáG)[Œ∏] + ŒΩ‚àá¬≤C + a(‚àáŒΩ)·µÄ
- [ ] Symmetric part S = (M + M·µÄ)/2
- [ ] Verify degeneracy conditions S¬∑a ‚âà 0
- [ ] Validation tests

### Phase 6: Code Generation üî≤ PENDING
- [x] Pickle caching for symbolic expressions
- [x] Export to readable Python (`symbolic_expressions_4params.py`)
- [ ] Convert to NumPy functions with lambdify
- [ ] Optimize with CSE
- [ ] Create `antisymmetric_part_analytical_qutrit()`
- [ ] Performance benchmarking

### Phase 7: Testing üî≤ PARTIAL
- [x] Basic validation: single-point numerical comparison
- [x] Structural tests: signs match, A‚â†0 in both
- [ ] Full validation tests (100+ states) - run offline
- [ ] Property verification tests
- [ ] Block structure tests
- [ ] Integration tests

### Phase 8: Documentation üî≤ PARTIAL
- [x] Docstrings with clear approximation labels
- [x] Demo script `examples/symbolic_vs_numerical_demo.py`
- [ ] Technical documentation
- [ ] Jupyter notebook

### Phase 9: Multi-Pair Extension üî≤ PENDING
- [ ] Direct sum assembly function
- [ ] Scaling tests
- [ ] Validation for 2-4 pairs

## Development Practices Learned

### Incremental Testing
1. **Profile first**: Know timing before running (`timeout 10 python -c "..."`)
2. **Minimal validation**: One point, one component first
3. **Cache aggressively**: Expensive computations saved to disk
4. **Clear naming**: `_taylor_` vs `_exact_` prevents confusion

### Timing Reference (4 symbolic parameters, qutrits d=3)
| Operation | Time |
|-----------|------|
| Density matrix | ~0.2s |
| Partial trace | ~0.2s |
| Eigenvalues (block structure) | ~0.04s |
| Differentiate exact entropy | 0.08s |
| Differentiate polynomial (Taylor) | ~0.05s |
| Differentiate log(cubic eigenvalue) | MINUTES (avoid!) |
| Load from cache | instant |

### Qubit/Qudit Generalization

**Current state**: Symbolic code is **qutrit-specific** (d=3, su(9) basis, 80 params)

**Numerical code**: `QuantumExponentialFamily(d=..., n_pairs=...)` handles any d

**Open questions**:
1. Does block structure exist for qubits (d=2)? ‚Üí 2√ó2 reduced œÅ, trivial eigenvalues
2. Does block structure exist for d=4,5,...? ‚Üí Need to investigate
3. Should symbolic code be generalized to arbitrary d?

**Recommendation**: Document the qutrit case fully, then consider generalization

### Key Files
- `qig/symbolic/su9_pair.py` - main symbolic computation
- `qig/symbolic/cache.py` - caching infrastructure  
- `qig/symbolic/results/symbolic_expressions_4params.py` - exported results
- `examples/symbolic_vs_numerical_demo.py` - validation demo

## References

### Primary References
- `quantum-generic-decomposition.tex`: The handle-turning procedure document
- Equation (283): Explicit formula for A
- Equation (238-239): Formula for ‚àáŒΩ

### Code References
- `qig/exponential_family.py`: Current numerical implementation
- `qig/structure_constants.py`: Structure constant computation
- `qig/generic.py`: Hamiltonian extraction from A
- `the-inaccessible-game/harmonic_oscillator.py`: Template for analytic forms

### Theoretical References
- Parzygnat & Russo (2024): Functorial information geometry
- Quantum origin paper: Lie-algebraic GENERIC decomposition
- Classical inaccessible game paper: Harmonic oscillator as template

### Mathematical Background
- Gell-Mann (1962): SU(3) structure constants
- Petz (1996): Quantum Fisher information and perturbation theory
- Bogoliubov-Kubo-Mori metric: Quantum covariance structure

## Notes

**Why this matters**: 
1. **Validation**: Analytic forms provide independent check on numerical implementation
2. **Insight**: Reveals how Lie structure creates simplifications
3. **Efficiency**: May be faster for repeated evaluations (though secondary benefit)
4. **Symbolic verification**: Can prove properties hold, not just check numerically
5. **Publication**: Strong evidence that GENERIC structure is emergent, not imposed

**Risk assessment**: Medium difficulty
- Symbolic computation is well-understood (have SymPy)
- Have working numerical implementation to validate against
- Have template from harmonic oscillator
- Main risk: expressions may be too complex to simplify
- Mitigation: Start simple, extend progressively

**Alternative approaches considered**:
1. **Finite differences for ‚àáŒΩ**: Loses symbolic structure, less accurate
2. **Numerical structure only**: Miss opportunity to validate and gain insight
3. **Only single qutrit**: Insufficient (need pair for entanglement)
4. **Full symbolic M**: Harder than needed (A formula is simpler)

**Decision**: Proceed with symbolic computation of constraint geometry ‚Üí A, as 
described in implementation plan.

