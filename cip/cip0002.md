---
author: "Neil D. Lawrence"
created: "2025-11-22"
id: "0002"
last_updated: "2025-11-22"
status: phase2_in_progress
tags:
- cip
- migration
- entanglement
- qutrit
- quantum-game
title: "Audit and Migrate Legacy Scripts to Support Entangled Systems"
---

# CIP-0002: Audit and Migrate Legacy Scripts to Support Entangled Systems

## Summary

Seven legacy scripts currently use **local operators only** (Pauli, Gell-Mann), which can ONLY represent separable states and cannot create entanglement. This CIP proposes to:

1. **Audit** each script to determine if it should study entangled systems
2. **Decide** whether migration to pair operators is needed
3. **Migrate** scripts that require entanglement to use `pair_basis=True`
4. **Validate** that results match paper claims after migration

This is critical because the paper discusses maximally entangled pairs as the "origin" of the quantum inaccessible game, but current implementations may not be able to represent these states.

## Motivation

### Critical Evidence from Paper

The paper's computational validation section states:

> "Creates **locally maximally entangled initial states** with $\sum_i \marginalVonNeumannEntropy_i = n\log d$ (maximal constraint value)"

This describes **Bell states** or maximally entangled pairs where each marginal is maximally mixed (h_i = log d).

**BUT** it then says:

> "The implementation uses **local Lie-algebraic operator bases** (Pauli matrices for qubits, Gell-Mann matrices for qutrits)"

**THIS IS THE PROBLEM!** Local operator bases (Pauli on individual qubits, Gell-Mann on individual qutrits) **CANNOT create maximally entangled states** like Bell states!

- Local operators ‚Üí only separable states ‚Üí I = 0 always
- Bell states require pair operators ‚Üí su(4) for qubit pairs, su(9) for qutrit pairs

**Conclusion**: The paper describes studying maximally entangled states, but the implementation may use local operators which cannot represent these states. This is a **fundamental inconsistency** that must be resolved.

### The Problem

Recent implementation of pair-based exponential family (`qig/pair_operators.py`) revealed that:

**Local operators** (current implementation):
- Can ONLY create separable states
- Mutual information I = 0 always
- C = H always (no entanglement)
- Structural identity GŒ∏ = -a holds
- Lagrange multiplier ŒΩ = -1 (constant)
- No genuine dynamics: F = 0 on manifold

**Pair operators** (new implementation):
- Can create entangled states (Bell states, etc.)
- Mutual information I > 0 
- C ‚â† H (genuine entanglement)
- Structural identity GŒ∏ ‚â† -a (broken)
- Lagrange multiplier ŒΩ varies
- Genuine dynamics: F ‚â† 0

### Scripts Requiring Audit

**7 legacy scripts** potentially affected:
1. `inaccessible_game_quantum.py` - Core quantum game implementation
2. `advanced_analysis.py` - Time parametrization comparisons
3. `validate_qutrit_optimality.py` - Qutrit optimality experiments
4. `quantum_qutrit_n3.py` - Custom qutrit implementation (doesn't use `qig`!)
5. `run_qutrit_experiment.py` - Qutrit experiment runner
6. `run_qutrit_quick.py` - Quick qutrit experiment runner
7. `test_quantum_qutrit.py` - Tests for custom qutrit code

### Critical Questions

1. **Qutrit optimality**: Does the paper claim qutrits are optimal for *entangled pairs* or *separable states*?
   - If entangled ‚Üí Current implementation is WRONG (uses local operators)
   - If separable ‚Üí Current implementation is correct (but should be documented)

2. **Origin of the game**: Paper states origin is "maximally entangled pairs"
   - Can current scripts even represent these states?
   - Or do they start somewhere else on the manifold?

3. **GENERIC decomposition**: Do results change with entanglement?
   - Antisymmetric part A changes significantly
   - Symmetric part S may have different degeneracies

## Detailed Description

### Phase 1: Audit ‚úÖ **COMPLETED**

**Test Script**: `audit_phase1_entanglement_check.py`

#### Test 1: Bell State Creation ‚úÖ

Verified that `create_lme_state()` DOES create genuine Bell states:

| Dimension | Joint H | Marginal Sum C | Mutual Information I | Purity | Status |
|-----------|---------|----------------|---------------------|--------|---------|
| d=2 (qubits) | ‚âà0 | 1.386294 | 1.386294 | 1.000 | ‚úì ENTANGLED |
| d=3 (qutrits) | ‚âà0 | 2.197225 | 2.197225 | 1.000 | ‚úì ENTANGLED |

**Conclusion**: Initial state creation is correct.

#### Test 2: LOCAL Operators CANNOT Represent Entanglement ‚ùå

Tested `QuantumExponentialFamily(n_sites=2, d=2, pair_basis=False)` with 6 local parameters:

| Configuration | I (mutual info) | C (marginal sum) | H (joint entropy) |
|---------------|-----------------|------------------|-------------------|
| Œ∏=0 (max mixed) | 0.000000 | 1.386294 | 1.386294 |
| random Œ∏, scale=2 | 0.000000 | 0.015867 | 0.015867 |
| random Œ∏, scale=4 | 0.000000 | 0.000010 | 0.000010 |
| random Œ∏, scale=6 | 0.000000 | 0.000000 | 0.000000 |
| random Œ∏, scale=8 | 0.000000 | 0.000058 | 0.000058 |

**Best achieved**: I = 0.000000  
**Target (Bell state)**: I = 1.386294  
**Gap**: 100% of entanglement lost!

**Conclusion**: LOCAL operators ALWAYS produce I = C - H = 0 (separable states).

#### Test 3: PAIR Operators CAN Represent Entanglement ‚úÖ

Tested `QuantumExponentialFamily(n_pairs=1, d=2, pair_basis=True)` with 15 pair parameters:

| Configuration | I (mutual info) | C (marginal sum) | H (joint entropy) |
|---------------|-----------------|------------------|-------------------|
| Œ∏=0 (max mixed) | 0.000000 | 1.386294 | 1.386294 |
| random Œ∏, scale=2 | 0.286346 | 0.310667 | 0.024321 |
| random Œ∏, scale=4 | 0.352401 | 0.352660 | 0.000259 |
| random Œ∏, scale=6 | 0.225156 | 0.283111 | 0.057955 |
| random Œ∏, scale=8 | **1.008704** | 1.008891 | 0.000186 |

**Best achieved**: I = 1.008704 (73% of maximal entanglement)  
**Target (Bell state)**: I = 1.386294  
**Success**: PAIR operators CAN create entanglement!

**Conclusion**: PAIR operators CAN create and represent entangled states.

#### Script Audit Results

**Scripts Using LOCAL Operators** (‚ùå Need Migration):

| Script | Uses qig? | Call Pattern | Status |
|--------|-----------|--------------|--------|
| `inaccessible_game_quantum.py` | ‚úì | `QuantumExponentialFamily(n_sites, d)` | ‚ùå LOCAL |
| `advanced_analysis.py` | ‚úì | `QuantumExponentialFamily(n_sites, d)` | ‚ùå LOCAL |
| `validate_qutrit_optimality.py` | ‚úì | `QuantumExponentialFamily(n_sites, d)` | ‚ùå LOCAL |

**All use LOCAL operators** ‚Üí Cannot represent entanglement ‚Üí Contradict paper claims

**Scripts Using Custom Implementation** (‚ö†Ô∏è Need Inspection):

| Script | Status | Notes |
|--------|--------|-------|
| `quantum_qutrit_n3.py` | ‚ö†Ô∏è CUSTOM | Implements own exponential family with local operators |
| `run_qutrit_experiment.py` | ‚ö†Ô∏è UNKNOWN | Need to check which exponential family used |
| `run_qutrit_quick.py` | ‚ö†Ô∏è UNKNOWN | Need to check which exponential family used |
| `test_quantum_qutrit.py` | ‚ö†Ô∏è TEST | Tests custom qutrit code |

#### The Inconsistency Confirmed

**What Actually Happens:**

```
Step 1: create_lme_state() creates Bell state œÅ_bell with I = 1.386
        ‚úì Correct

Step 2: Initialize QuantumExponentialFamily(n_sites=2, d=2)
        ‚úì Uses local operators (6 params)

Step 3: Try to represent œÅ_bell with local operators
        ‚ùå Closest state has I = 0 (projects to separable!)

Step 4: Integrate dynamics with F(Œ∏) = -Œ†(G¬∑Œ∏)
        ‚ùå All subsequent states have I = 0
        ‚ùå Entanglement is NEVER preserved or evolved
```

#### Implications for Paper Claims

| Claim | With LOCAL operators | With PAIR operators |
|-------|---------------------|---------------------|
| "Locally maximally entangled initial states" | ‚ùå FALSE (I=0) | ‚úì TRUE (I>0) |
| "Bell states with D=4" | ‚ùå Cannot represent | ‚úì Can represent |
| "Marginal entropy conservation" | ‚úì Works | ‚úì Works |
| "Monotonic entropy increase" | ‚ö†Ô∏è Trivial (H=C always) | ‚úì Non-trivial |
| "GENERIC decomposition M = S + A" | ‚ö†Ô∏è May be trivial | ‚úì Non-trivial |
| "Qutrit optimality" | ‚ùå Meaning unclear | ‚ö†Ô∏è Needs re-evaluation |

#### Implications for Dynamics

**With LOCAL operators** (current):
- H = C always (no entanglement)
- GŒ∏ = -‚àáC (structural identity)
- F(Œ∏) = 0 everywhere (equilibrium manifold)
- **No dynamics!**

**With PAIR operators** (correct):
- H < C possible (entanglement present, I = C-H > 0)
- GŒ∏ ‚â† -‚àáC (identity broken)
- F(Œ∏) ‚â† 0 (genuine dynamics)
- **Rich dynamics on manifold**

#### **VERDICT**: HIGH RISK - Full migration required

Priority order:
1. **High**: `inaccessible_game_quantum.py` - Main validation script
2. **High**: `validate_qutrit_optimality.py` - Critical for paper claims
3. **High**: `quantum_qutrit_n3.py` - Custom code, needs full rewrite
4. **Medium**: `advanced_analysis.py` - Extended analysis
5. **Medium**: `run_qutrit_experiment.py`, `run_qutrit_quick.py` - Experimental scripts
6. **Low**: `test_quantum_qutrit.py` - Test code

---

### Phase 2: Migration ‚è≥ **IN PROGRESS**

**Goal**: Migrate scripts from LOCAL operators to PAIR operators to enable genuine entanglement.

#### Completed Migrations ‚úÖ

**1. `inaccessible_game_quantum.py`** (Commit: 571ddc2)
- **Changes**:
  - Removed 145-line local `QuantumExponentialFamily` class
  - Import from `qig.exponential_family` instead
  - Use `pair_basis=True` with `n_pairs = n_sites // 2`
  - Added even n_sites requirement check
  - Updated tests: 2 qubits (1 pair), 2 qutrits (1 pair)
- **Verification**:
  - ‚úì Initializes correctly (15 params for qubit pair)
  - ‚úì Creates entanglement (I = 0.469 with random Œ∏)
  - ‚úì Bell state has I = 1.386 (maximal)
- **Status**: Complete, dynamics may be slow

**2. `validate_qutrit_optimality.py`** (Commit: 2ac2ead)
- **Changes**:
  - Use `QuantumExponentialFamily(n_pairs, d, pair_basis=True)`
  - Removed `eps` parameter from `fisher_information()` call
  - Added even n_sites check
- **Verification**:
  - ‚úì Computes Œ±(2) = 0.399 for d=2, n_sites=2
  - ‚úì Entropy gradient R = 0.554
  - ‚úì BKM metric computed successfully
- **Status**: Complete, qutrit optimality results may differ from paper

**3. `advanced_analysis.py`** (Commit: fa8da00)
- **Changes**:
  - Updated all 4 functions to use pair operators:
    - `compare_time_parametrisations()`
    - `plot_generic_decomposition_evolution()`
    - `entropy_gradient_geometry()`
    - `compare_qubit_qutrit_optimality()`
  - Added even n_sites checks
  - Graceful handling of odd n_sites (skip with message)
- **Status**: Complete, testing pending

#### Remaining Migrations ‚ö†Ô∏è

**4. `quantum_qutrit_n3.py`** - **CRITICAL BLOCKER**
- **Current state**:
  - 745-line custom implementation
  - Does NOT use qig library
  - Implements own exponential family with LOCAL operators
  - Used by 3 other scripts: `run_qutrit_experiment.py`, `run_qutrit_quick.py`, `test_quantum_qutrit.py`
- **Challenge**:
  - This is a dependency for other Phase 2 scripts
  - Must be migrated before those scripts can be tested
- **Options**:
  1. **Replace with qig**: Delete custom code, import from `qig.exponential_family`
     - Pro: Leverage validated implementation
     - Pro: Get pair operators for free
     - Con: Results might differ slightly
     - Con: Breaks backward compatibility
  2. **Update custom code**: Add pair operator support to custom implementation
     - Pro: Keep standalone reference
     - Pro: More control
     - Con: More code to maintain
     - Con: Duplicate effort
- **Recommendation**: Option 1 (replace with qig) - consistent with other migrations

**5-7. `run_qutrit_experiment.py`, `run_qutrit_quick.py`, `test_quantum_qutrit.py`**
- **Status**: Blocked by `quantum_qutrit_n3.py` migration
- **Action**: Migrate after resolving item 4

#### Phase 2 Summary

| Script | Status | Commit | Entanglement Verified |
|--------|--------|--------|----------------------|
| `inaccessible_game_quantum.py` | ‚úÖ Complete | 571ddc2 | Yes (I=0.469) |
| `validate_qutrit_optimality.py` | ‚úÖ Complete | 2ac2ead | Yes (Œ±=0.399) |
| `advanced_analysis.py` | ‚úÖ Complete | fa8da00 | Pending test |
| `quantum_qutrit_n3.py` | ‚ö†Ô∏è Blocked | - | N/A (custom code) |
| `run_qutrit_experiment.py` | ‚è≥ Waiting | - | Blocked by #4 |
| `run_qutrit_quick.py` | ‚è≥ Waiting | - | Blocked by #4 |
| `test_quantum_qutrit.py` | ‚è≥ Waiting | - | Blocked by #4 |

**Next Step**: Decide on `quantum_qutrit_n3.py` migration strategy.

---

### Phase 1 Methodology

For each script, answer:

**A. What does the paper claim this experiment studies?**
- Review relevant paper sections
- Check if entanglement is mentioned
- Check if "maximally entangled pairs" appear in context

**B. What does the code actually implement?**
```python
# Search for initialization patterns
QuantumExponentialFamily(n_sites=..., d=...)  # Local operators
QuantumExponentialFamily(n_pairs=..., pair_basis=True)  # Pair operators

# Check for entanglement assumptions
I > 0  # Assumes entanglement
C != H  # Assumes entanglement
```

**C. Are there hardcoded assumptions?**
- `ŒΩ = -1` (only valid for local operators)
- `GŒ∏ = -a` (structural identity, only for local operators)
- `I = 0` or `C = H` (only true for separable states)

**D. Decision matrix:**

| Paper Claims | Code Uses | Action |
|-------------|-----------|--------|
| Separable states | Local operators | ‚úÖ OK - Document only |
| Separable states | Pair operators | ‚ö†Ô∏è Over-engineered but harmless |
| Entangled states | Local operators | üö® **WRONG - Must migrate** |
| Entangled states | Pair operators | ‚úÖ OK |
| Unclear | Local operators | ‚ùì Need to clarify with paper author |

### Phase 2: Migration Plan (If Needed)

#### Script 1: `inaccessible_game_quantum.py`

**Current state:**
- Uses `QuantumExponentialFamily` from `qig.exponential_family`
- Default initialization likely uses local operators

**Migration:**
```python
# OLD
exp_fam = QuantumExponentialFamily(n_sites=2, d=2)

# NEW (for entangled systems)
exp_fam = QuantumExponentialFamily(n_pairs=1, d=2, pair_basis=True)
```

**Impacts:**
- Number of parameters: 6 ‚Üí 15 for qubit pair
- Computational cost: ~2x slower (acceptable)
- Results: Should see I > 0, genuine dynamics

#### Script 2: `advanced_analysis.py`

**Current state:**
- Higher-level analysis using `inaccessible_game_quantum.py`
- Time parametrization comparisons

**Questions:**
- Does entropy-time parametrization work differently with entanglement?
- Do GENERIC decomposition plots change?

**Migration:**
- Update imports if `inaccessible_game_quantum.py` changes
- Add entanglement metrics to plots (I, C-H)
- Compare separable vs entangled behavior

#### Script 3: `validate_qutrit_optimality.py`

**Current state:**
- Uses `QuantumExponentialFamily(n_sites, d)` with local operators
- Claims to validate qutrit optimality

**CRITICAL QUESTION:** 
Is qutrit optimality about:
- **A. Separable qutrits?** (n=3, 8 parameters each, 24 total)
- **B. Entangled qutrit pairs?** (n=1 pair, 80 parameters)

**Migration (if B):**
```python
# OLD (wrong for entangled pairs)
exp_fam = QuantumExponentialFamily(n_sites=3, d=3)  # 3 qutrits, 24 params

# NEW (correct for entangled pairs)
exp_fam = QuantumExponentialFamily(n_pairs=1, d=3, pair_basis=True)  # 80 params
# OR for multiple pairs
exp_fam = QuantumExponentialFamily(n_pairs=3, d=3, pair_basis=True)  # 240 params
```

**Validation:**
- Re-run Fisher information computations
- Check if qutrit optimality still holds with entanglement
- **May need to update paper** if results change!

#### Scripts 4-7: Custom Qutrit Code

**`quantum_qutrit_n3.py`** (and related scripts):
- **Does NOT use `qig` modules at all**
- Custom implementation of exponential family
- Has its own Gell-Mann matrices, Fisher metric, etc.

**Options:**

**A. Migrate to `qig`** (Recommended)
- Replace custom code with `QuantumExponentialFamily`
- Benefits:
  - Use validated implementations
  - Get pair operator support for free
  - Easier to maintain
- Risks:
  - Results might change slightly (numerical differences)
  - Need to validate against old implementation

**B. Update custom code for entanglement**
- Add pair operator generation to `quantum_qutrit_n3.py`
- Implement own su(9) generators
- Benefits:
  - Keep standalone reference implementation
  - More control over numerics
- Risks:
  - More code to maintain
  - May diverge from main `qig` implementation

**C. Keep as-is for separable states**
- Document that it's for separable states only
- Use `qig` with pair basis for entangled experiments
- Benefits:
  - Clear separation of concerns
  - Reference for separable case
- Risks:
  - Confusion about which to use

### Phase 3: Validation

After migration, verify:

1. **Numerical results:**
   - Fisher metric values match (within tolerance)
   - Constraint preservation maintained
   - GENERIC decomposition correct

2. **Entanglement metrics:**
   - I > 0 for entangled states
   - C - H = I (consistency check)
   - Marginal entropies sum correctly

3. **Dynamics:**
   - F ‚â† 0 (genuine dynamics exist)
   - GŒ∏ ‚â† -a (structural identity broken)
   - ŒΩ varies (not constant at -1)

4. **Paper claims:**
   - Qutrit optimality still holds (or update paper)
   - Trajectory visualizations match paper figures
   - GENERIC structure matches paper description

## Implementation Status

### Phase 1: Audit
- [ ] Review paper for entanglement claims in each experiment
- [ ] Audit `inaccessible_game_quantum.py` for local vs pair operators
- [ ] Audit `advanced_analysis.py` for entanglement assumptions
- [ ] **CRITICAL**: Audit `validate_qutrit_optimality.py` - entangled or separable?
- [ ] Audit `quantum_qutrit_n3.py` - what does it implement?
- [ ] Document findings in decision matrix
- [ ] Consult with paper author if unclear

### Phase 2: Migration (Conditional)
- [ ] **Decision point**: Which scripts need migration?
- [ ] Migrate `inaccessible_game_quantum.py` (if needed)
- [ ] Migrate `advanced_analysis.py` (if needed)
- [ ] Migrate `validate_qutrit_optimality.py` (if needed)
- [ ] Decide on `quantum_qutrit_n3.py`: migrate, update, or keep as-is
- [ ] Update `run_qutrit_experiment.py` and `run_qutrit_quick.py`
- [ ] Update `test_quantum_qutrit.py`

### Phase 3: Validation
- [ ] Run all migrated scripts
- [ ] Compare results with paper claims
- [ ] Verify entanglement metrics are correct
- [ ] Check GENERIC decomposition
- [ ] Update paper if results differ
- [ ] Update documentation to clarify local vs pair operators

## Testing Strategy

**Before migration:**
- Run all legacy scripts and save outputs as baseline
- Document expected behavior from paper

**After migration:**
- Run updated scripts and compare with baseline
- For numerical differences:
  - Verify they're due to entanglement (I > 0, C ‚â† H)
  - Check if paper claims still hold
  - Document any discrepancies

**Regression tests:**
- Add tests for both local and pair operators
- Verify local operators still work (for separable cases)
- Verify pair operators enable entanglement
- Check backward compatibility

## Impact Assessment

### Low Risk (Documentation Only)
If experiments were always meant to study separable states:
- Document that local operators are intentional
- No code changes needed
- No paper changes needed

**LIKELIHOOD: LOW** - Paper explicitly mentions "locally maximally entangled initial states" and "Bell states"

### Medium Risk (Extend Experiments)
If experiments should compare separable vs entangled:
- Add pair operator experiments alongside local ones
- Compare behavior in both regimes
- Enhance paper with additional results

**LIKELIHOOD: MEDIUM** - Possible the paper meant to study both regimes

### High Risk (Fundamental Error) ‚ö†Ô∏è **MOST LIKELY**
If experiments claimed entanglement but used local operators:
- **All results may be wrong**
- Must re-run with pair operators
- **May need to update paper significantly**
- Qutrit optimality claim may change

**LIKELIHOOD: HIGH** - Strong evidence from paper text:
1. Paper says "locally maximally entangled initial states" (Bell states)
2. Paper says "uses local Lie-algebraic operator bases" (Pauli, Gell-Mann)
3. **These are incompatible!** Local operators cannot create Bell states
4. This suggests implementation does not match paper's description

**RECOMMENDATION**: Assume High Risk and proceed with full audit and migration. If audit reveals lower risk, we can scale back.

## Related Work

**Completed (enables this CIP):**
- ‚úÖ CIP-0001: Module consolidation
- ‚úÖ `qig/pair_operators.py`: su(d¬≤) generators for entangled pairs
- ‚úÖ `qig/exponential_family.py`: Support for `pair_basis=True`
- ‚úÖ Full Jacobian implementation for entangled systems
- ‚úÖ 26 comprehensive tests validating pair operators

**Dependencies:**
- Paper review (to determine intent)
- Author consultation (if intent unclear)

**Follow-up work:**
- Update validation documentation after migration
- Add tutorial comparing local vs pair operators
- Document when to use which approach

## References

**Code:**
- `qig/exponential_family.py` - Supports both local and pair operators
- `qig/pair_operators.py` - su(d¬≤) generators for entangled pairs
- Legacy scripts (listed above)

**Backlog:**
- `2025-11-22_entangled-pair-exponential-family.md` (Completed)
- `2025-11-22_analytic-jacobian-implementation.md` (Completed)

**Paper:**
- *The Origin of the Inaccessible Game* - Section on qutrit optimality
- Check references to "maximally entangled pairs"
- Check GENERIC decomposition claims

## Decision Points

**Before starting Phase 2, answer:**

1. **CRITICAL: Resolve the contradiction in computational validation paragraph**
   - Paper claims: "Creates locally maximally entangled initial states" (Bell states)
   - Paper also claims: "Uses local Lie-algebraic operator bases" (Pauli, Gell-Mann)
   - **These are incompatible!** Which is correct?
   - **Action**: Check what the code ACTUALLY does vs what paper describes
   - **If code uses local operators**: Must migrate to pair operators OR update paper

2. **What does the paper claim about qutrit optimality?**
   - Optimal for what? Separable states or entangled pairs?
   - Review relevant sections and quotes
   - Check if qutrit advantage depends on entanglement

3. **What is the "origin" of the game?**
   - Paper says "maximally entangled pairs"
   - Can current scripts represent these states?
   - Or is "origin" a conceptual point not used in numerics?
   - Check initialization code in validation scripts

4. **Do GENERIC decomposition results require entanglement?**
   - Check if antisymmetric part A requires I > 0
   - Check if paper's A values are consistent with F ‚â† 0
   - Verify that "antisymmetric part remains subdominant" with pair operators

5. **Are trajectory figures in paper from local or pair operators?**
   - Check figure generation code
   - Verify if trajectories show I > 0 or I = 0
   - Confirm constraint values match paper claims

**Document answers before proceeding with migration!**

**URGENT FIRST STEP**: Run existing validation scripts and check:
- Do they initialize Bell states or separable states?
- What is the mutual information I at t=0?
- Do trajectories show entanglement (I > 0) or not (I = 0)?

